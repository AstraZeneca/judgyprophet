{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is judgyprophet ? judgyprophet is a Bayesian forecasting algorithm based on Prophet, that enables forecasting while using information known by the business about future events. The aim is to enable users to perform forecasting with judgmental adjustment , in a way that is mathematically as sound as possible. Some events will have a big effect on your timeseries. Some of which you are aware of ahead of time. For example: An existing product entering a new market. A price change to a product. These events will typically cause a large change in your timeseries of e.g. product sales, which a standard statistical forecast will consistently underestimate. The business will often have good estimates (or at least better than your statistical forecast) about how these events will affect your timeseries. But this is difficult to encode into your statistical forecasting algorithm. One option is to use a regressor, but this typically works poorly. This is because you have no data on the event before it occurs, and the statistical forecast does not know how to balance the information in your regressor and trend after the event occurs (which can lead to erratic behaviour). judgyprophet solves this problem by encoding the business estimate of how the event will affect the forecast (the judgmental adjustment) as a Bayesian informative prior. Before the event occurs, this business information is used to reflect the forecast of what will happen post-event e.g. the estimated uplift in product sales once the event has happened. After the event occurs, we update what the business thinks will happen, with what we see happening in the actuals. This is done using standard Bayesian updating. Installation 1. install judgyprophet python package using pip pip install judgyprophet 2. compile the STAN model judgyprophet depends on STAN , whose models have to be compiled before running. So to use judgyprophet , you have to compile the model. Do this in the shell using python -c \"from judgyprophet import JudgyProphet; JudgyProphet().compile()\" or in python using from judgyprophet import JudgyProphet JudgyProphet () . compile () This will take a while. But you only have to run this once, after the initial install. Roadmap Some things on our roadmap: Currently judgyprophet STAN file is only tested on Unix-based Linux or Mac machines. We aim to fully test Windows machines ASAP. Option to run full MCMC, rather than just L-BFGS. Prediction intervals Regressors/holidays Quickstart Tutorial Imagine your business currently operates in the US, but is launching its product in Europe. As a result it anticipates a sharp uptake in sales (which it has an estimate of). As your forecasting team, they come to you and ask you to account for this. Let's look at how we might do this using judgyprophet with some example data, where we know what happened. First let's plot this: from judgyprophet.tutorials.resources import get_trend_event example_data = get_trend_event () p = example_data . plot . line () We can see that product sales increased sharply from about September 2020. Suppose it was a launch in a new market, and that the business had an initial estimate of the impact in May 2020. The business expected the slope increase to be 6. Let's use judgyprophet to forecast this series from May 2020. We do this by encoding the initial business estimate as a trend event . from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Create the expected trend events by consulting with the business trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : 6 } ] # Cutoff the data to May 2020 data_may2020 = example_data . loc [: \"2020-05-01\" ] # Make the forecast with the business estimated level event # We have no level events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_may2020 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -3.4521 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 3 -2.92768 0.054987 8.11433e-14 1 1 7 Optimization terminated normally: Convergence detected: gradient norm is below tolerance Because we are in May 2020, the forecasting algorithm has nothing to use for learning; so just uses the business estimate. Let's plot the result: from judgyprophet.tutorials.resources import plot_forecast plot_forecast ( actuals = example_data , predictions = predictions , cutoff = \"2020-05-01\" , events = trend_events ) INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. INFO:prophet:Disabling weekly seasonality. Run prophet with weekly_seasonality=True to override this. INFO:prophet:Disabling daily seasonality. Run prophet with daily_seasonality=True to override this. Initial log joint probability = -17.0121 Iteration 1. Log joint probability = 10.4753. Improved by 27.4875. Iteration 2. Log joint probability = 12.7533. Improved by 2.27796. Iteration 3. Log joint probability = 25.4696. Improved by 12.7163. Iteration 4. Log joint probability = 26.707. Improved by 1.2374. Iteration 5. Log joint probability = 26.7075. Improved by 0.000514342. Iteration 6. Log joint probability = 26.7104. Improved by 0.00296558. Iteration 7. Log joint probability = 26.7122. Improved by 0.00171322. Iteration 8. Log joint probability = 26.7157. Improved by 0.00351772. Iteration 9. Log joint probability = 26.7159. Improved by 0.000208268. Iteration 10. Log joint probability = 26.7159. Improved by 6.64977e-05. Iteration 11. Log joint probability = 26.716. Improved by 6.89899e-05. Iteration 12. Log joint probability = 26.716. Improved by 3.06578e-05. Iteration 13. Log joint probability = 26.716. Improved by 8.91492e-07. Iteration 14. Log joint probability = 26.716. Improved by 8.71052e-09. We can see judgyprophet is accounting for the increased trend, but the business slightly overestimated the increase in sales due to the product launch. Let's fast forward to January 2021, the business want to reforecast based on their estimate, and what they've seen so far for the product launch. This is where judgyprophet comes into its own. Once actuals are observed after the event has taken place, judgyprophet updates its estimate of what the event impact is. Let's look at this in action: # Cutoff the data to January 2021 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Reforecast using the new actuals, not we are at Jan 2021 jp = JudgyProphet () jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: 6. Damping: None. Initial log joint probability = -309.562 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 10 -1.64341 2.10244e-05 3.61281e-06 1 1 15 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Now let's plot the results: plot_forecast ( actuals = example_data , predictions = predictions , cutoff = \"2021-01-01\" , events = trend_events ) INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. INFO:prophet:Disabling weekly seasonality. Run prophet with weekly_seasonality=True to override this. INFO:prophet:Disabling daily seasonality. Run prophet with daily_seasonality=True to override this. Initial log joint probability = -24.5881 Iteration 1. Log joint probability = -1.06803. Improved by 23.5201. Iteration 2. Log joint probability = 11.6215. Improved by 12.6895. Iteration 3. Log joint probability = 36.5271. Improved by 24.9056. Iteration 4. Log joint probability = 37.3776. Improved by 0.850488. Iteration 5. Log joint probability = 37.6489. Improved by 0.271259. Iteration 6. Log joint probability = 37.6547. Improved by 0.00580657. Iteration 7. Log joint probability = 37.7831. Improved by 0.128419. Iteration 8. Log joint probability = 37.7884. Improved by 0.00527858. Iteration 9. Log joint probability = 37.789. Improved by 0.000612124. Iteration 10. Log joint probability = 37.7891. Improved by 9.93823e-05. Iteration 11. Log joint probability = 37.7902. Improved by 0.00112416. Iteration 12. Log joint probability = 37.7902. Improved by 3.17397e-06. Iteration 13. Log joint probability = 37.7902. Improved by 1.59404e-05. Iteration 14. Log joint probability = 37.7902. Improved by 5.06854e-07. Iteration 15. Log joint probability = 37.7902. Improved by 6.87792e-07. Iteration 16. Log joint probability = 37.7902. Improved by 4.82761e-08. Iteration 17. Log joint probability = 37.7902. Improved by 2.50385e-07. Iteration 18. Log joint probability = 37.7902. Improved by 6.60322e-09. In this case, once judgyprophet observes the data post-event, the Bayesian updating starts to realise the business estimate is a bit large, so it reduces it. This was a simple example to demonstrate judgyprophet . You can add many trend events into a single forecasting horizon, add damping. You can also add level events \u2013 changes in the forecasting level; and seasonality see our other tutorials for details about this.","title":"Home"},{"location":"#what-is-judgyprophet","text":"judgyprophet is a Bayesian forecasting algorithm based on Prophet, that enables forecasting while using information known by the business about future events. The aim is to enable users to perform forecasting with judgmental adjustment , in a way that is mathematically as sound as possible. Some events will have a big effect on your timeseries. Some of which you are aware of ahead of time. For example: An existing product entering a new market. A price change to a product. These events will typically cause a large change in your timeseries of e.g. product sales, which a standard statistical forecast will consistently underestimate. The business will often have good estimates (or at least better than your statistical forecast) about how these events will affect your timeseries. But this is difficult to encode into your statistical forecasting algorithm. One option is to use a regressor, but this typically works poorly. This is because you have no data on the event before it occurs, and the statistical forecast does not know how to balance the information in your regressor and trend after the event occurs (which can lead to erratic behaviour). judgyprophet solves this problem by encoding the business estimate of how the event will affect the forecast (the judgmental adjustment) as a Bayesian informative prior. Before the event occurs, this business information is used to reflect the forecast of what will happen post-event e.g. the estimated uplift in product sales once the event has happened. After the event occurs, we update what the business thinks will happen, with what we see happening in the actuals. This is done using standard Bayesian updating.","title":"What is judgyprophet?"},{"location":"#installation","text":"","title":"Installation"},{"location":"#1-install-judgyprophet-python-package-using-pip","text":"pip install judgyprophet","title":"1. install judgyprophet python package using pip"},{"location":"#2-compile-the-stan-model","text":"judgyprophet depends on STAN , whose models have to be compiled before running. So to use judgyprophet , you have to compile the model. Do this in the shell using python -c \"from judgyprophet import JudgyProphet; JudgyProphet().compile()\" or in python using from judgyprophet import JudgyProphet JudgyProphet () . compile () This will take a while. But you only have to run this once, after the initial install.","title":"2. compile the STAN model"},{"location":"#roadmap","text":"Some things on our roadmap: Currently judgyprophet STAN file is only tested on Unix-based Linux or Mac machines. We aim to fully test Windows machines ASAP. Option to run full MCMC, rather than just L-BFGS. Prediction intervals Regressors/holidays","title":"Roadmap"},{"location":"#quickstart-tutorial","text":"Imagine your business currently operates in the US, but is launching its product in Europe. As a result it anticipates a sharp uptake in sales (which it has an estimate of). As your forecasting team, they come to you and ask you to account for this. Let's look at how we might do this using judgyprophet with some example data, where we know what happened. First let's plot this: from judgyprophet.tutorials.resources import get_trend_event example_data = get_trend_event () p = example_data . plot . line () We can see that product sales increased sharply from about September 2020. Suppose it was a launch in a new market, and that the business had an initial estimate of the impact in May 2020. The business expected the slope increase to be 6. Let's use judgyprophet to forecast this series from May 2020. We do this by encoding the initial business estimate as a trend event . from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Create the expected trend events by consulting with the business trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : 6 } ] # Cutoff the data to May 2020 data_may2020 = example_data . loc [: \"2020-05-01\" ] # Make the forecast with the business estimated level event # We have no level events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_may2020 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -3.4521 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 3 -2.92768 0.054987 8.11433e-14 1 1 7 Optimization terminated normally: Convergence detected: gradient norm is below tolerance Because we are in May 2020, the forecasting algorithm has nothing to use for learning; so just uses the business estimate. Let's plot the result: from judgyprophet.tutorials.resources import plot_forecast plot_forecast ( actuals = example_data , predictions = predictions , cutoff = \"2020-05-01\" , events = trend_events ) INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. INFO:prophet:Disabling weekly seasonality. Run prophet with weekly_seasonality=True to override this. INFO:prophet:Disabling daily seasonality. Run prophet with daily_seasonality=True to override this. Initial log joint probability = -17.0121 Iteration 1. Log joint probability = 10.4753. Improved by 27.4875. Iteration 2. Log joint probability = 12.7533. Improved by 2.27796. Iteration 3. Log joint probability = 25.4696. Improved by 12.7163. Iteration 4. Log joint probability = 26.707. Improved by 1.2374. Iteration 5. Log joint probability = 26.7075. Improved by 0.000514342. Iteration 6. Log joint probability = 26.7104. Improved by 0.00296558. Iteration 7. Log joint probability = 26.7122. Improved by 0.00171322. Iteration 8. Log joint probability = 26.7157. Improved by 0.00351772. Iteration 9. Log joint probability = 26.7159. Improved by 0.000208268. Iteration 10. Log joint probability = 26.7159. Improved by 6.64977e-05. Iteration 11. Log joint probability = 26.716. Improved by 6.89899e-05. Iteration 12. Log joint probability = 26.716. Improved by 3.06578e-05. Iteration 13. Log joint probability = 26.716. Improved by 8.91492e-07. Iteration 14. Log joint probability = 26.716. Improved by 8.71052e-09. We can see judgyprophet is accounting for the increased trend, but the business slightly overestimated the increase in sales due to the product launch. Let's fast forward to January 2021, the business want to reforecast based on their estimate, and what they've seen so far for the product launch. This is where judgyprophet comes into its own. Once actuals are observed after the event has taken place, judgyprophet updates its estimate of what the event impact is. Let's look at this in action: # Cutoff the data to January 2021 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Reforecast using the new actuals, not we are at Jan 2021 jp = JudgyProphet () jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: 6. Damping: None. Initial log joint probability = -309.562 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 10 -1.64341 2.10244e-05 3.61281e-06 1 1 15 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Now let's plot the results: plot_forecast ( actuals = example_data , predictions = predictions , cutoff = \"2021-01-01\" , events = trend_events ) INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. INFO:prophet:Disabling weekly seasonality. Run prophet with weekly_seasonality=True to override this. INFO:prophet:Disabling daily seasonality. Run prophet with daily_seasonality=True to override this. Initial log joint probability = -24.5881 Iteration 1. Log joint probability = -1.06803. Improved by 23.5201. Iteration 2. Log joint probability = 11.6215. Improved by 12.6895. Iteration 3. Log joint probability = 36.5271. Improved by 24.9056. Iteration 4. Log joint probability = 37.3776. Improved by 0.850488. Iteration 5. Log joint probability = 37.6489. Improved by 0.271259. Iteration 6. Log joint probability = 37.6547. Improved by 0.00580657. Iteration 7. Log joint probability = 37.7831. Improved by 0.128419. Iteration 8. Log joint probability = 37.7884. Improved by 0.00527858. Iteration 9. Log joint probability = 37.789. Improved by 0.000612124. Iteration 10. Log joint probability = 37.7891. Improved by 9.93823e-05. Iteration 11. Log joint probability = 37.7902. Improved by 0.00112416. Iteration 12. Log joint probability = 37.7902. Improved by 3.17397e-06. Iteration 13. Log joint probability = 37.7902. Improved by 1.59404e-05. Iteration 14. Log joint probability = 37.7902. Improved by 5.06854e-07. Iteration 15. Log joint probability = 37.7902. Improved by 6.87792e-07. Iteration 16. Log joint probability = 37.7902. Improved by 4.82761e-08. Iteration 17. Log joint probability = 37.7902. Improved by 2.50385e-07. Iteration 18. Log joint probability = 37.7902. Improved by 6.60322e-09. In this case, once judgyprophet observes the data post-event, the Bayesian updating starts to realise the business estimate is a bit large, so it reduces it. This was a simple example to demonstrate judgyprophet . You can add many trend events into a single forecasting horizon, add damping. You can also add level events \u2013 changes in the forecasting level; and seasonality see our other tutorials for details about this.","title":"Quickstart Tutorial"},{"location":"Quickstart/","text":"Quickstart Tutorial Installation Imagine your business currently operates in the US, but is launching its product in Europe. As a result it anticipates a sharp uptake in sales (which it has an estimate of). As your forecasting team, they come to you and ask you to account for this. Let's look at how we might do this using judgyprophet with some example data, where we know what happened. First let's plot this: from judgyprophet.tutorials.resources import get_trend_event example_data = get_trend_event () p = example_data . plot . line () We can see that product sales increased sharply from about September 2020. Suppose it was a launch in a new market, and that the business had an initial estimate of the impact in May 2020. The business expected the slope increase to be 6. Let's use judgyprophet to forecast this series from May 2020. We do this by encoding the initial business estimate as a trend event . from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Create the expected trend events by consulting with the business trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : 6 } ] # Cutoff the data to May 2020 data_may2020 = example_data . loc [: \"2020-05-01\" ] # Make the forecast with the business estimated level event # We have no level events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_may2020 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -3.07317 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -2.92768 9.35253e-05 0.000181658 1 1 8 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Because we are in May 2020, the forecasting algorithm has nothing to use for learning; so just uses the business estimate. Let's plot the result: from judgyprophet.tutorials.resources import plot_forecast plot_forecast ( actuals = example_data , predictions = predictions , cutoff = \"2020-05-01\" , events = trend_events ) INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. INFO:prophet:Disabling weekly seasonality. Run prophet with weekly_seasonality=True to override this. INFO:prophet:Disabling daily seasonality. Run prophet with daily_seasonality=True to override this. Initial log joint probability = -17.0121 Iteration 1. Log joint probability = 10.4753. Improved by 27.4875. Iteration 2. Log joint probability = 12.7533. Improved by 2.27796. Iteration 3. Log joint probability = 25.4696. Improved by 12.7163. Iteration 4. Log joint probability = 26.707. Improved by 1.2374. Iteration 5. Log joint probability = 26.7075. Improved by 0.000514342. Iteration 6. Log joint probability = 26.7104. Improved by 0.00296558. Iteration 7. Log joint probability = 26.7122. Improved by 0.00171322. Iteration 8. Log joint probability = 26.7157. Improved by 0.00351772. Iteration 9. Log joint probability = 26.7159. Improved by 0.000208268. Iteration 10. Log joint probability = 26.7159. Improved by 6.64977e-05. Iteration 11. Log joint probability = 26.716. Improved by 6.89899e-05. Iteration 12. Log joint probability = 26.716. Improved by 3.06578e-05. Iteration 13. Log joint probability = 26.716. Improved by 8.91492e-07. Iteration 14. Log joint probability = 26.716. Improved by 8.71052e-09. We can see judgyprophet is accounting for the increased trend, but the business slightly overestimated the increase in sales due to the product launch. Let's fast forward to January 2021, the business want to reforecast based on their estimate, and what they've seen so far for the product launch. This is where judgyprophet comes into its own. Once actuals are observed after the event has taken place, judgyprophet updates its estimate of what the event impact is. Let's look at this in action: # Cutoff the data to January 2021 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Reforecast using the new actuals, not we are at Jan 2021 jp = JudgyProphet () jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: 6. Damping: None. Initial log joint probability = -96.2602 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -1.64341 2.40778e-05 0.000287473 1 1 10 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Now let's plot the results: plot_forecast ( actuals = example_data , predictions = predictions , cutoff = \"2021-01-01\" , events = trend_events ) INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. INFO:prophet:Disabling weekly seasonality. Run prophet with weekly_seasonality=True to override this. INFO:prophet:Disabling daily seasonality. Run prophet with daily_seasonality=True to override this. Initial log joint probability = -24.5881 Iteration 1. Log joint probability = -1.06803. Improved by 23.5201. Iteration 2. Log joint probability = 11.6215. Improved by 12.6895. Iteration 3. Log joint probability = 36.5271. Improved by 24.9056. Iteration 4. Log joint probability = 37.3776. Improved by 0.850488. Iteration 5. Log joint probability = 37.6489. Improved by 0.271259. Iteration 6. Log joint probability = 37.6547. Improved by 0.00580657. Iteration 7. Log joint probability = 37.7831. Improved by 0.128419. Iteration 8. Log joint probability = 37.7884. Improved by 0.00527858. Iteration 9. Log joint probability = 37.789. Improved by 0.000612124. Iteration 10. Log joint probability = 37.7891. Improved by 9.93823e-05. Iteration 11. Log joint probability = 37.7902. Improved by 0.00112416. Iteration 12. Log joint probability = 37.7902. Improved by 3.17397e-06. Iteration 13. Log joint probability = 37.7902. Improved by 1.59404e-05. Iteration 14. Log joint probability = 37.7902. Improved by 5.06854e-07. Iteration 15. Log joint probability = 37.7902. Improved by 6.87792e-07. Iteration 16. Log joint probability = 37.7902. Improved by 4.82761e-08. Iteration 17. Log joint probability = 37.7902. Improved by 2.50385e-07. Iteration 18. Log joint probability = 37.7902. Improved by 6.60322e-09. In this case, once judgyprophet observes the data post-event, the Bayesian updating starts to realise the business estimate is a bit large, so it reduces it. This was a simple example to demonstrate judgyprophet . You can add many trend events into a single forecasting horizon, add damping. You can also add level events \u2013 changes in the forecasting level; and seasonality see our other tutorials for details about this.","title":"Quickstart"},{"location":"Quickstart/#quickstart-tutorial","text":"","title":"Quickstart Tutorial"},{"location":"Quickstart/#installation","text":"Imagine your business currently operates in the US, but is launching its product in Europe. As a result it anticipates a sharp uptake in sales (which it has an estimate of). As your forecasting team, they come to you and ask you to account for this. Let's look at how we might do this using judgyprophet with some example data, where we know what happened. First let's plot this: from judgyprophet.tutorials.resources import get_trend_event example_data = get_trend_event () p = example_data . plot . line () We can see that product sales increased sharply from about September 2020. Suppose it was a launch in a new market, and that the business had an initial estimate of the impact in May 2020. The business expected the slope increase to be 6. Let's use judgyprophet to forecast this series from May 2020. We do this by encoding the initial business estimate as a trend event . from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Create the expected trend events by consulting with the business trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : 6 } ] # Cutoff the data to May 2020 data_may2020 = example_data . loc [: \"2020-05-01\" ] # Make the forecast with the business estimated level event # We have no level events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_may2020 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -3.07317 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -2.92768 9.35253e-05 0.000181658 1 1 8 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Because we are in May 2020, the forecasting algorithm has nothing to use for learning; so just uses the business estimate. Let's plot the result: from judgyprophet.tutorials.resources import plot_forecast plot_forecast ( actuals = example_data , predictions = predictions , cutoff = \"2020-05-01\" , events = trend_events ) INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. INFO:prophet:Disabling weekly seasonality. Run prophet with weekly_seasonality=True to override this. INFO:prophet:Disabling daily seasonality. Run prophet with daily_seasonality=True to override this. Initial log joint probability = -17.0121 Iteration 1. Log joint probability = 10.4753. Improved by 27.4875. Iteration 2. Log joint probability = 12.7533. Improved by 2.27796. Iteration 3. Log joint probability = 25.4696. Improved by 12.7163. Iteration 4. Log joint probability = 26.707. Improved by 1.2374. Iteration 5. Log joint probability = 26.7075. Improved by 0.000514342. Iteration 6. Log joint probability = 26.7104. Improved by 0.00296558. Iteration 7. Log joint probability = 26.7122. Improved by 0.00171322. Iteration 8. Log joint probability = 26.7157. Improved by 0.00351772. Iteration 9. Log joint probability = 26.7159. Improved by 0.000208268. Iteration 10. Log joint probability = 26.7159. Improved by 6.64977e-05. Iteration 11. Log joint probability = 26.716. Improved by 6.89899e-05. Iteration 12. Log joint probability = 26.716. Improved by 3.06578e-05. Iteration 13. Log joint probability = 26.716. Improved by 8.91492e-07. Iteration 14. Log joint probability = 26.716. Improved by 8.71052e-09. We can see judgyprophet is accounting for the increased trend, but the business slightly overestimated the increase in sales due to the product launch. Let's fast forward to January 2021, the business want to reforecast based on their estimate, and what they've seen so far for the product launch. This is where judgyprophet comes into its own. Once actuals are observed after the event has taken place, judgyprophet updates its estimate of what the event impact is. Let's look at this in action: # Cutoff the data to January 2021 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Reforecast using the new actuals, not we are at Jan 2021 jp = JudgyProphet () jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: 6. Damping: None. Initial log joint probability = -96.2602 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -1.64341 2.40778e-05 0.000287473 1 1 10 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Now let's plot the results: plot_forecast ( actuals = example_data , predictions = predictions , cutoff = \"2021-01-01\" , events = trend_events ) INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. INFO:prophet:Disabling weekly seasonality. Run prophet with weekly_seasonality=True to override this. INFO:prophet:Disabling daily seasonality. Run prophet with daily_seasonality=True to override this. Initial log joint probability = -24.5881 Iteration 1. Log joint probability = -1.06803. Improved by 23.5201. Iteration 2. Log joint probability = 11.6215. Improved by 12.6895. Iteration 3. Log joint probability = 36.5271. Improved by 24.9056. Iteration 4. Log joint probability = 37.3776. Improved by 0.850488. Iteration 5. Log joint probability = 37.6489. Improved by 0.271259. Iteration 6. Log joint probability = 37.6547. Improved by 0.00580657. Iteration 7. Log joint probability = 37.7831. Improved by 0.128419. Iteration 8. Log joint probability = 37.7884. Improved by 0.00527858. Iteration 9. Log joint probability = 37.789. Improved by 0.000612124. Iteration 10. Log joint probability = 37.7891. Improved by 9.93823e-05. Iteration 11. Log joint probability = 37.7902. Improved by 0.00112416. Iteration 12. Log joint probability = 37.7902. Improved by 3.17397e-06. Iteration 13. Log joint probability = 37.7902. Improved by 1.59404e-05. Iteration 14. Log joint probability = 37.7902. Improved by 5.06854e-07. Iteration 15. Log joint probability = 37.7902. Improved by 6.87792e-07. Iteration 16. Log joint probability = 37.7902. Improved by 4.82761e-08. Iteration 17. Log joint probability = 37.7902. Improved by 2.50385e-07. Iteration 18. Log joint probability = 37.7902. Improved by 6.60322e-09. In this case, once judgyprophet observes the data post-event, the Bayesian updating starts to realise the business estimate is a bit large, so it reduces it. This was a simple example to demonstrate judgyprophet . You can add many trend events into a single forecasting horizon, add damping. You can also add level events \u2013 changes in the forecasting level; and seasonality see our other tutorials for details about this.","title":"Installation"},{"location":"reference/","text":"judgyprophet API Reference judgyprophet.JudgyProphet class JudgyProphet: \"\"\" A class to fit an 'judgyprophet' model: a forecasting algorithm which incorporates business information about known events using Bayesian informative priors. The input is the actuals, as well as information about a number of known change in level or change in trend events. This information is used to feed data to informative priors, which is used as a quantitative judgemental pre-adjustment. This model is a wrapper for the stan model 'judgyprophet.stan'. When the object is instantiated, the compiled STAN model is looked for in 'stan/build/judgyprophet.pkl'. If this is not available then the compile() method will need to be run before fit(). This will compile the stan code for future use. :param prebuild_path: (optional) a custom path to compile the stan build code to. When .compile() is run, this path will be used to save the compiled model. It will also be used to access the build path when the object is instantiated. The usecase for this is if you don't have write access to your python install path. \"\"\" JudgyProphet.fit def fit( self, data: pd.Series, level_events: List[Dict[str, Any]], trend_events: List[Dict[str, Any]], unspecified_changepoints: Union[int, Iterable] = 0, seasonal_period: Optional[int] = None, seasonal_type: str = 'add', event_start_cutoff: int = 4, event_end_cutoff: int = 0, fourier_order: Optional[int] = None, sigma_unspecified_changepoints: float = .1, sigma_base_bias: float = 1., sigma_base_trend: float = 1., sigma_level: float = .1, sigma_trend: float = .1, sigma_seasonal: float = 1., sigma_actuals: float = .5, starting_jitter: float = .1, **kwargs ): \"\"\" Fit a judgyprophet model to the actuals provided in 'data'. Changes in trend will be added to the dates in trend_events with initial gradient as defined. Changes in level will be added to the dates in level_events with initial shift as defined. This is a wrapper that samples from the STAN model 'stan/judgyprophet.stan' using the data provided. :param actuals: A pandas series of the actual timeseries to forecast. It is assumed there are no missing data points, i.e. x[1] is the observation directly following x[0], etc. The index of the series should indicate the time point of the observation. E.g. if observations are timestamps, the index would be pd.DatetimeIndex; if observations are indexed by discrete time points, the index would be an integer index. The indexes in level_events and trend_events should be the same type as the index of actuals. :param level_events: A list of dictionaries. Each dict should have the following entries - 'index' the start index of the event (i.e. index = i assumes the start of the event is at location actuals[i]). The index should be of the same type as the actuals index. - 'c0' the estimated level increase following the event :param trend_events: A list of dictionaries. Each dict should have the following entries - 'index' the start index of the event (i.e. index = i assumes the start of the event is at location actuals[i]). The index should be of the same type as the actuals index. - 'm0' the estimated gradient increase following the event - 'gamma' (Optional) the damping to use for the trend. This is a float between 0 and 1. It's not recommended to be below 0.8 and must be 0 > gamma <= 1. If gamma is missing from the dict, or gamma = 1, a linear trend is used (i.e. no damping). :param unspecified_changepoints: (optional, default 0) The number of 'prophet' like changepoints (i.e. learnt from the data as there has been an unanticipated change to the timeseries trend or level). Either an int of the number of changepoints which are distributed evenly along the data, or an ArrayLike of indexes of the data where changepoints are required. If it is an ArrayLike, each element should be the same type as the actuals index. :param seasonal_period: (optional, default None) The seasonal period of the timeseries. This should be an integer. If this is set to None or 1, no seasonality will be used. Seasonality is modelled using Fourier series. :param seasonal_type: (optional, default 'add') the type of seasonality to use: - 'add' for additive - 'mult' for multiplicative :param event_start_cutoff: the number of data points of history required before an event before a changepoint will be put there (otherwise it is absorbed into the base trend and will not be learned). :param event_end_cutoff: the number of data points required after an event before a changepoint will be put there and its parameters will be learnt by the model (otherwise it is predicted using m0). :param fourier_order: (optional, int) the number of fourier terms to use for modelling seasonality. If None, this will be set to seasonal_period - 1. This is useful if you have a long seasonal period and not much data. You can use a fourier order that is lower than the seasonal period. :param sigma_unspecified_changepoints: The standard deviation of the prior on the unspecified changepoints. The smaller this is, the higher the L1 penalty on the changepoints. :param sigma_base_bias: The standard deviation of the prior on the base bias (i.e. bias before any changepoints or events are observed). The smaller this is, the higher the regularisation on the parameter. :param sigma_base_trend: The standard deviation of the prior on the base trend (i.e. trend before any changepoints or events are observed). The smaller this is, the higher the regularisation on the parameter. :param sigma_level: The standard deviation of the prior on level events. The smaller this is, the more the parameter will be regularised towards the initial estimate 'c0'. :param sigma_trend: The standard deviation of the prior on trend events. The smaller this is, the more the parameter will be regularised towards the initial estimate 'm0'. :param sigma_seasonal: The standard deviation of the prior on seasonality. The smaller this is, the more the parameter will be regularised towards 0. :param sigma_actuals: The standard deviation of the prior on actuals noise. :param starting_jitter: jitter in the starting values -- resolves optimisation problems. :param **kwargs: Any extra keyword arguments will be passed onto StanModel.sampling (e.g. iter, chains) \"\"\" JudgyProphet.predict def predict(self, horizon: int = 0) -> pd.DataFrame: \"\"\" Predict model up to the supplied horizon. If no horizon is given, the insample fit is returned. :param horizon: (Optional, default 0) the horizon to predict upto. Must be a positive integer. ... :returns: a dataframe of prediction results, including a column indicating if the point is insample or not. \"\"\" JudgyProphet.compile def compile(self): \"\"\" Compile model from the STAN code and save as pickle in self.stan_build_path. This is only required if compilation was unsuccessful during installation. \"\"\" JudgyProphet.get_model_output def get_model_output( self, rescale: bool = True ) -> Dict[str, Dict]: \"\"\" Get model output, if 'rescale' is True, it will be rescaled back onto the original scale. The data is rescaled to have mean-0, var-1 so priors are relatively stable. But this means the learnt parameters will be for the rescaled data. This function rescales those parameters back onto the original scale (if rescale set) and returns them. If 'seasonal_type' was set to 'mult', then we are unable to rescale the parameters back as they are too tightly coupled. If this is the case, set 'rescale' to False to get unscaled parameters. ... :returns: model output dict that's on the original scale. ... :raises: NotImplementedError if 'seasonal_type' is 'mult' and 'rescale' is set to True. \"\"\"","title":"API Reference"},{"location":"reference/#judgyprophet-api-reference","text":"","title":"judgyprophet API Reference"},{"location":"reference/#judgyprophetjudgyprophet","text":"class JudgyProphet: \"\"\" A class to fit an 'judgyprophet' model: a forecasting algorithm which incorporates business information about known events using Bayesian informative priors. The input is the actuals, as well as information about a number of known change in level or change in trend events. This information is used to feed data to informative priors, which is used as a quantitative judgemental pre-adjustment. This model is a wrapper for the stan model 'judgyprophet.stan'. When the object is instantiated, the compiled STAN model is looked for in 'stan/build/judgyprophet.pkl'. If this is not available then the compile() method will need to be run before fit(). This will compile the stan code for future use. :param prebuild_path: (optional) a custom path to compile the stan build code to. When .compile() is run, this path will be used to save the compiled model. It will also be used to access the build path when the object is instantiated. The usecase for this is if you don't have write access to your python install path. \"\"\"","title":"judgyprophet.JudgyProphet"},{"location":"reference/#judgyprophetfit","text":"def fit( self, data: pd.Series, level_events: List[Dict[str, Any]], trend_events: List[Dict[str, Any]], unspecified_changepoints: Union[int, Iterable] = 0, seasonal_period: Optional[int] = None, seasonal_type: str = 'add', event_start_cutoff: int = 4, event_end_cutoff: int = 0, fourier_order: Optional[int] = None, sigma_unspecified_changepoints: float = .1, sigma_base_bias: float = 1., sigma_base_trend: float = 1., sigma_level: float = .1, sigma_trend: float = .1, sigma_seasonal: float = 1., sigma_actuals: float = .5, starting_jitter: float = .1, **kwargs ): \"\"\" Fit a judgyprophet model to the actuals provided in 'data'. Changes in trend will be added to the dates in trend_events with initial gradient as defined. Changes in level will be added to the dates in level_events with initial shift as defined. This is a wrapper that samples from the STAN model 'stan/judgyprophet.stan' using the data provided. :param actuals: A pandas series of the actual timeseries to forecast. It is assumed there are no missing data points, i.e. x[1] is the observation directly following x[0], etc. The index of the series should indicate the time point of the observation. E.g. if observations are timestamps, the index would be pd.DatetimeIndex; if observations are indexed by discrete time points, the index would be an integer index. The indexes in level_events and trend_events should be the same type as the index of actuals. :param level_events: A list of dictionaries. Each dict should have the following entries - 'index' the start index of the event (i.e. index = i assumes the start of the event is at location actuals[i]). The index should be of the same type as the actuals index. - 'c0' the estimated level increase following the event :param trend_events: A list of dictionaries. Each dict should have the following entries - 'index' the start index of the event (i.e. index = i assumes the start of the event is at location actuals[i]). The index should be of the same type as the actuals index. - 'm0' the estimated gradient increase following the event - 'gamma' (Optional) the damping to use for the trend. This is a float between 0 and 1. It's not recommended to be below 0.8 and must be 0 > gamma <= 1. If gamma is missing from the dict, or gamma = 1, a linear trend is used (i.e. no damping). :param unspecified_changepoints: (optional, default 0) The number of 'prophet' like changepoints (i.e. learnt from the data as there has been an unanticipated change to the timeseries trend or level). Either an int of the number of changepoints which are distributed evenly along the data, or an ArrayLike of indexes of the data where changepoints are required. If it is an ArrayLike, each element should be the same type as the actuals index. :param seasonal_period: (optional, default None) The seasonal period of the timeseries. This should be an integer. If this is set to None or 1, no seasonality will be used. Seasonality is modelled using Fourier series. :param seasonal_type: (optional, default 'add') the type of seasonality to use: - 'add' for additive - 'mult' for multiplicative :param event_start_cutoff: the number of data points of history required before an event before a changepoint will be put there (otherwise it is absorbed into the base trend and will not be learned). :param event_end_cutoff: the number of data points required after an event before a changepoint will be put there and its parameters will be learnt by the model (otherwise it is predicted using m0). :param fourier_order: (optional, int) the number of fourier terms to use for modelling seasonality. If None, this will be set to seasonal_period - 1. This is useful if you have a long seasonal period and not much data. You can use a fourier order that is lower than the seasonal period. :param sigma_unspecified_changepoints: The standard deviation of the prior on the unspecified changepoints. The smaller this is, the higher the L1 penalty on the changepoints. :param sigma_base_bias: The standard deviation of the prior on the base bias (i.e. bias before any changepoints or events are observed). The smaller this is, the higher the regularisation on the parameter. :param sigma_base_trend: The standard deviation of the prior on the base trend (i.e. trend before any changepoints or events are observed). The smaller this is, the higher the regularisation on the parameter. :param sigma_level: The standard deviation of the prior on level events. The smaller this is, the more the parameter will be regularised towards the initial estimate 'c0'. :param sigma_trend: The standard deviation of the prior on trend events. The smaller this is, the more the parameter will be regularised towards the initial estimate 'm0'. :param sigma_seasonal: The standard deviation of the prior on seasonality. The smaller this is, the more the parameter will be regularised towards 0. :param sigma_actuals: The standard deviation of the prior on actuals noise. :param starting_jitter: jitter in the starting values -- resolves optimisation problems. :param **kwargs: Any extra keyword arguments will be passed onto StanModel.sampling (e.g. iter, chains) \"\"\"","title":"JudgyProphet.fit"},{"location":"reference/#judgyprophetpredict","text":"def predict(self, horizon: int = 0) -> pd.DataFrame: \"\"\" Predict model up to the supplied horizon. If no horizon is given, the insample fit is returned. :param horizon: (Optional, default 0) the horizon to predict upto. Must be a positive integer. ... :returns: a dataframe of prediction results, including a column indicating if the point is insample or not. \"\"\"","title":"JudgyProphet.predict"},{"location":"reference/#judgyprophetcompile","text":"def compile(self): \"\"\" Compile model from the STAN code and save as pickle in self.stan_build_path. This is only required if compilation was unsuccessful during installation. \"\"\"","title":"JudgyProphet.compile"},{"location":"reference/#judgyprophetget_model_output","text":"def get_model_output( self, rescale: bool = True ) -> Dict[str, Dict]: \"\"\" Get model output, if 'rescale' is True, it will be rescaled back onto the original scale. The data is rescaled to have mean-0, var-1 so priors are relatively stable. But this means the learnt parameters will be for the rescaled data. This function rescales those parameters back onto the original scale (if rescale set) and returns them. If 'seasonal_type' was set to 'mult', then we are unable to rescale the parameters back as they are too tightly coupled. If this is the case, set 'rescale' to False to get unscaled parameters. ... :returns: model output dict that's on the original scale. ... :raises: NotImplementedError if 'seasonal_type' is 'mult' and 'rescale' is set to True. \"\"\"","title":"JudgyProphet.get_model_output"},{"location":"technical_description/","text":"Introduction Forecasters are commonly asked to account for known future events . These are large business events which will have an effect on the forecast for e.g. the sales of a product, which it is known will happen ahead of time. Examples could be: An existing product entering a new market A price change to a product ... The business will often have critical information about how they believe these events will affect the sales of a given product. At the time, this information is the best we have as to how this event will affect product sales. Since they will cause significant bias in an actuals only based forecasting algorithm, it is important to incorporate this information into the forecast. One option is to use judgmental post-adjustment . This is where business experts will change the output of a statistical forecast based on what they think will happen when this event occurs. This typically works quite well before an event, as it is adjusting the forecast for information it is unable to use. But after an event has occurred, it's difficult to know how much information about the event the statistical forecast is using. Since the outcome of these events can vary rapidly, and the outcome can be very different to what is expected, business information can become outdated. This can lead to adjusted forecasts that are more inaccurate than the statistical base. Another option is to use regressors. We tried this method ourselves. It worked well before the event as it would more often than not adjust the forecasting algorithm for its known bias. Once again though, after the event occurred this regressor degraded quickly even if the outcome of the event deviated only slightly from what was expected (which happens most of the time). This could lead to large forecasting errors. judgyprophet aims to solve this problem by encoding these events using Bayesian informative priors. Before the event occurs, judgyprophet uses the business information to adjust likely biases in its statistical forecast due to a known business event. After the event, judgyprophet adjusts its estimate using Bayesian updating. This attempts to balance the expert knowledge of the business, with what is actually being observed in the actuals. This enables it to adjust rapidly as the event deviates from what is expected by the business. As the name suggests, judgyprophet is based on the prophet algorithm, and uses concept of changepoints. It splits the changepoints into two groups: business known changepoints -- which are used to encode events with known business information; business unspecified changepoints -- which act more like the prophet changepoints and enable the forecast to adjust to unanticipated changes in trend and level of the timeseries. The forecasting model Similar to Prophet, we use a decomposable timeseries model \\[ y(t) = g(t) + s(t) + \\epsilon_t, \\] where \\(g(t)\\) is the trend function, and \\(s(t)\\) is the seasonality function. The main difference being we further decompose \\(g(t)\\) into three components \\[ g(t) = L(t) + M(t) + U(t). \\] These components are defined as follows: \\(L(t)\\) -- business known level events. These are events that lead to sudden level shifts in the timeseries that the business know about ahead of time. An example might be the \\$ sales for an inelastic good (e.g. food) when there is a price increase. \\(M(t)\\) -- business known trend events. These are events that lead to a steady increase in the target that the business know about ahead of time. An example might be the product sales for an existing product that is entering a new market (e.g. a console game being released in a new country). \\(U(t)\\) -- unspecified changepoint events. These are events that cause a change in trend that are unanticipated by the business ahead of time. These are equivalent to Prophet's linear changepoints. They help to capture unanticipated changes in the target. Business Known Level Events: \\(L(t)\\) Level events are business known events that will lead to sudden level shifts in the timeseries (see the quickstart tutorial for an example). Suppose the business identify \\(J\\) possible level events, define the business estimate of the change in level for event \\(j \\in J\\), which occurs at time \\(\\tau_j\\), to be \\(l_{0j}\\), and define the parameter defining the unknown actual level change to be \\(l_j\\). Then the level event model is defined as follows \\[ L(t) = \\sum_{j=1}^J l_j \\mathbf 1 \\{t \\geq \\tau_j \\}, \\] where \\(c_l\\) is drawn from the following prior \\[ c_j \\sim N(l_{0j}, \\sigma_l^2), \\qquad \\text{for } j = 1, ..., J. \\] Here \\(N\\) denotes the normal distribution; \\(\\sigma_c\\) is the standard deviation set for the level events, which is a settable parameter in judgyprophet . The idea is that before the event is observed, \\(l_{0j}\\) is used as the estimate for the level change, as that is the best estimate we have. But as we move to observing the event, the actuals are used to learn a better value for \\(l_j\\) using Bayesian updating. Because of the prior we have set, \\(l_j\\) will be penalized from taking values away from \\(l_{0j}\\). This ensures that \\(l_j\\) won't make large jumps from the business estimate when not much data has been observed. This stops the algorithm from making erratic forecasts. This technique is similar to the idea of ridge regression. Business Known Trend Events: \\(M(t)\\) Trend events are business known events that will lead to a trend change in the timeseries after the event (e.g. a gradual and repeating increase in sales. See the quickstart tutorial for an example). We start by discussing the simplest trend event available in judgyprophet : a linear one. It's important to think about damping in our model though. Often when a product is released to a new market, there is an increase in sales, followed by a steady slow down of this as the market is saturated. This can be modelled in judgyprophet , and is covered in the next subsection. Suppose the business identify \\(I\\) possible trend events, define the business estimate of the change in trend for event \\(i\\), which occurs at time \\(\\tau_i\\), to be \\(m_{0i}\\), and define the parameter defining the unknown actual trend change to be \\(m_i\\). Then the trend event model is defined as follows \\[ M(t) = \\sum_{i=1}^I m_i s_i(t). \\] Here we define \\(s_i(t) = \\max\\{t - \\tau_i, 0\\}\\), i.e.\\ before the event time \\(\\tau_i\\) \\(s_i(t)\\) is 0, and after that it measures the time since the event. Similarly to for level events we define the prior for \\(m_i\\) to be \\[ m_i \\sim N(m_{0i}, \\sigma_m^2), \\] where \\(\\sigma_m\\) is the standard deviation set for trend events. It sets the sensitivity of the model to the actuals post any trend event. Damping We found using logistics curves, as in Prophet, to handle damping to be too sensitive to the maximum capacity constant (defined by \\(C\\) in Prophet). Therefore we instead use a model inspired by Holt's damped trend exponential smoothing model (see e.g. Forecasting Principle and Practice. Hyndman, Athanasopoulos. ). This model is very similar to the model used for linear trends. But we add one further hyperparameter for each event \\(\\gamma_i\\). This parameter defines the level of damping for event \\(i\\) in exactly the same way as Holt's damped trend method (see e.g. Forecasting Principle and Practice. Hyndman, Athanasopoulos. ). This constant is typically set between 0.8 and 1, where 1 is equivalent to a linear trend, and 0.8 indicates quite heavy damping. First set \\(d(t)\\) to be the following \\[ d_i(t) = \\frac{(1 - \\gamma_i^t)}{1 - \\gamma_i} \\mathbf 1 \\{t > 0\\}. \\] Then we define the damped trend to be \\[ M(t) = \\sum_{i=1}^I m_i d_i(\\max\\{t - \\tau_i, 0\\}). \\] We assign the same prior to \\(m_i\\) as in the linear trend case. This is similar to Holt's damping with trend because we can expand \\(d_i(t)\\) using the properties of geometric series to get \\[ d_i(t) = \\frac{1 - \\gamma_i^t}{1 - \\gamma_i} \\mathbf 1 \\{t > 0\\} = \\mathbf 1 \\{t > 0\\} \\sum_{t=0}^{t-1} \\gamma^t. \\] This is very similar in form to the exponential smoothing equations. For now, \\(\\gamma_i\\) is a hyperparameter rather than a learned Bayesian parameter, i.e.\\ it will not be updated as we observe actuals. We found the parameter was quite poorly predicted when it is modelled. We have added trying to add this as a learnt parameter again to the roadmap. Unspecified changepoint events: \\(U(t)\\) These events are very similar to Prophet's original concept of changepoints. These are sudden changes in level or trend in the training period of the timeseries. Unlike Prophet, we do not use these changes for prediction, only to capture observed, unanticipated events in the timeseries. They are normally evenly dispersed across the timeseries, or exact locations can be specified by the user. Let there be \\(k \\in K\\) unspecified changepoint events, occurring at time \\(\\tau_k\\), let the unknown level and trend changes be \\(v_k\\) and \\(w_k\\) respectively, then we define \\[ U(t) = \\sum_{k=1}^K v_k \\mathbf 1\\{t \\geq \\tau_k\\} + w_k \\max\\{t - \\tau_k, 0\\}. \\] Similar to Prophet, in order to penalise using these unspecified changepoints when unnecessary, rather than a normal prior as for the above events, we use a Laplace prior. This is equivalent to setting an \\(L_1\\) or Lasso penalty on the changes -- hopefully sending them to 0 if they are unnecessary. Specifically we set \\[ v_k, w_k \\sim \\text{Laplace}(0, \\sigma_U), \\qquad \\text{for }k = 1, ..., K. \\] Seasonality Similar to Prophet, we encode seasonality using Fourier series. The user defines the seasonal period \\(s_S\\), and the fourier period \\(s_F\\) (this is automatically set to \\(s_S - 1\\) if unspecified). Then seasonality is defined as \\[ s(t) = \\sum_{j=1}^{s_F} \\beta_j f_j(t), \\] where \\[ f_j(t) = \\mathbf 1\\{j \\text{mod} 2 = 0\\} \\cos\\left(\\frac{2 \\pi \\lfloor j / 2 \\rfloor t}{s_F}\\right) + \\mathbf 1\\{j \\text{mod} 2 = 1\\} \\sin\\left(\\frac{2 \\pi (\\lfloor j / 2 \\rfloor + 1) t}{s_F}\\right). \\] For each seasonal coefficient \\(\\beta_j\\), we set the prior \\[ \\beta_j \\sim N(0, \\sigma_s). \\]","title":"Technical Description"},{"location":"technical_description/#introduction","text":"Forecasters are commonly asked to account for known future events . These are large business events which will have an effect on the forecast for e.g. the sales of a product, which it is known will happen ahead of time. Examples could be: An existing product entering a new market A price change to a product ... The business will often have critical information about how they believe these events will affect the sales of a given product. At the time, this information is the best we have as to how this event will affect product sales. Since they will cause significant bias in an actuals only based forecasting algorithm, it is important to incorporate this information into the forecast. One option is to use judgmental post-adjustment . This is where business experts will change the output of a statistical forecast based on what they think will happen when this event occurs. This typically works quite well before an event, as it is adjusting the forecast for information it is unable to use. But after an event has occurred, it's difficult to know how much information about the event the statistical forecast is using. Since the outcome of these events can vary rapidly, and the outcome can be very different to what is expected, business information can become outdated. This can lead to adjusted forecasts that are more inaccurate than the statistical base. Another option is to use regressors. We tried this method ourselves. It worked well before the event as it would more often than not adjust the forecasting algorithm for its known bias. Once again though, after the event occurred this regressor degraded quickly even if the outcome of the event deviated only slightly from what was expected (which happens most of the time). This could lead to large forecasting errors. judgyprophet aims to solve this problem by encoding these events using Bayesian informative priors. Before the event occurs, judgyprophet uses the business information to adjust likely biases in its statistical forecast due to a known business event. After the event, judgyprophet adjusts its estimate using Bayesian updating. This attempts to balance the expert knowledge of the business, with what is actually being observed in the actuals. This enables it to adjust rapidly as the event deviates from what is expected by the business. As the name suggests, judgyprophet is based on the prophet algorithm, and uses concept of changepoints. It splits the changepoints into two groups: business known changepoints -- which are used to encode events with known business information; business unspecified changepoints -- which act more like the prophet changepoints and enable the forecast to adjust to unanticipated changes in trend and level of the timeseries.","title":"Introduction"},{"location":"technical_description/#the-forecasting-model","text":"Similar to Prophet, we use a decomposable timeseries model \\[ y(t) = g(t) + s(t) + \\epsilon_t, \\] where \\(g(t)\\) is the trend function, and \\(s(t)\\) is the seasonality function. The main difference being we further decompose \\(g(t)\\) into three components \\[ g(t) = L(t) + M(t) + U(t). \\] These components are defined as follows: \\(L(t)\\) -- business known level events. These are events that lead to sudden level shifts in the timeseries that the business know about ahead of time. An example might be the \\$ sales for an inelastic good (e.g. food) when there is a price increase. \\(M(t)\\) -- business known trend events. These are events that lead to a steady increase in the target that the business know about ahead of time. An example might be the product sales for an existing product that is entering a new market (e.g. a console game being released in a new country). \\(U(t)\\) -- unspecified changepoint events. These are events that cause a change in trend that are unanticipated by the business ahead of time. These are equivalent to Prophet's linear changepoints. They help to capture unanticipated changes in the target.","title":"The forecasting model"},{"location":"technical_description/#business-known-level-events-lt","text":"Level events are business known events that will lead to sudden level shifts in the timeseries (see the quickstart tutorial for an example). Suppose the business identify \\(J\\) possible level events, define the business estimate of the change in level for event \\(j \\in J\\), which occurs at time \\(\\tau_j\\), to be \\(l_{0j}\\), and define the parameter defining the unknown actual level change to be \\(l_j\\). Then the level event model is defined as follows \\[ L(t) = \\sum_{j=1}^J l_j \\mathbf 1 \\{t \\geq \\tau_j \\}, \\] where \\(c_l\\) is drawn from the following prior \\[ c_j \\sim N(l_{0j}, \\sigma_l^2), \\qquad \\text{for } j = 1, ..., J. \\] Here \\(N\\) denotes the normal distribution; \\(\\sigma_c\\) is the standard deviation set for the level events, which is a settable parameter in judgyprophet . The idea is that before the event is observed, \\(l_{0j}\\) is used as the estimate for the level change, as that is the best estimate we have. But as we move to observing the event, the actuals are used to learn a better value for \\(l_j\\) using Bayesian updating. Because of the prior we have set, \\(l_j\\) will be penalized from taking values away from \\(l_{0j}\\). This ensures that \\(l_j\\) won't make large jumps from the business estimate when not much data has been observed. This stops the algorithm from making erratic forecasts. This technique is similar to the idea of ridge regression.","title":"Business Known Level Events: \\(L(t)\\)"},{"location":"technical_description/#business-known-trend-events-mt","text":"Trend events are business known events that will lead to a trend change in the timeseries after the event (e.g. a gradual and repeating increase in sales. See the quickstart tutorial for an example). We start by discussing the simplest trend event available in judgyprophet : a linear one. It's important to think about damping in our model though. Often when a product is released to a new market, there is an increase in sales, followed by a steady slow down of this as the market is saturated. This can be modelled in judgyprophet , and is covered in the next subsection. Suppose the business identify \\(I\\) possible trend events, define the business estimate of the change in trend for event \\(i\\), which occurs at time \\(\\tau_i\\), to be \\(m_{0i}\\), and define the parameter defining the unknown actual trend change to be \\(m_i\\). Then the trend event model is defined as follows \\[ M(t) = \\sum_{i=1}^I m_i s_i(t). \\] Here we define \\(s_i(t) = \\max\\{t - \\tau_i, 0\\}\\), i.e.\\ before the event time \\(\\tau_i\\) \\(s_i(t)\\) is 0, and after that it measures the time since the event. Similarly to for level events we define the prior for \\(m_i\\) to be \\[ m_i \\sim N(m_{0i}, \\sigma_m^2), \\] where \\(\\sigma_m\\) is the standard deviation set for trend events. It sets the sensitivity of the model to the actuals post any trend event.","title":"Business Known Trend Events: \\(M(t)\\)"},{"location":"technical_description/#damping","text":"We found using logistics curves, as in Prophet, to handle damping to be too sensitive to the maximum capacity constant (defined by \\(C\\) in Prophet). Therefore we instead use a model inspired by Holt's damped trend exponential smoothing model (see e.g. Forecasting Principle and Practice. Hyndman, Athanasopoulos. ). This model is very similar to the model used for linear trends. But we add one further hyperparameter for each event \\(\\gamma_i\\). This parameter defines the level of damping for event \\(i\\) in exactly the same way as Holt's damped trend method (see e.g. Forecasting Principle and Practice. Hyndman, Athanasopoulos. ). This constant is typically set between 0.8 and 1, where 1 is equivalent to a linear trend, and 0.8 indicates quite heavy damping. First set \\(d(t)\\) to be the following \\[ d_i(t) = \\frac{(1 - \\gamma_i^t)}{1 - \\gamma_i} \\mathbf 1 \\{t > 0\\}. \\] Then we define the damped trend to be \\[ M(t) = \\sum_{i=1}^I m_i d_i(\\max\\{t - \\tau_i, 0\\}). \\] We assign the same prior to \\(m_i\\) as in the linear trend case. This is similar to Holt's damping with trend because we can expand \\(d_i(t)\\) using the properties of geometric series to get \\[ d_i(t) = \\frac{1 - \\gamma_i^t}{1 - \\gamma_i} \\mathbf 1 \\{t > 0\\} = \\mathbf 1 \\{t > 0\\} \\sum_{t=0}^{t-1} \\gamma^t. \\] This is very similar in form to the exponential smoothing equations. For now, \\(\\gamma_i\\) is a hyperparameter rather than a learned Bayesian parameter, i.e.\\ it will not be updated as we observe actuals. We found the parameter was quite poorly predicted when it is modelled. We have added trying to add this as a learnt parameter again to the roadmap.","title":"Damping"},{"location":"technical_description/#unspecified-changepoint-events-ut","text":"These events are very similar to Prophet's original concept of changepoints. These are sudden changes in level or trend in the training period of the timeseries. Unlike Prophet, we do not use these changes for prediction, only to capture observed, unanticipated events in the timeseries. They are normally evenly dispersed across the timeseries, or exact locations can be specified by the user. Let there be \\(k \\in K\\) unspecified changepoint events, occurring at time \\(\\tau_k\\), let the unknown level and trend changes be \\(v_k\\) and \\(w_k\\) respectively, then we define \\[ U(t) = \\sum_{k=1}^K v_k \\mathbf 1\\{t \\geq \\tau_k\\} + w_k \\max\\{t - \\tau_k, 0\\}. \\] Similar to Prophet, in order to penalise using these unspecified changepoints when unnecessary, rather than a normal prior as for the above events, we use a Laplace prior. This is equivalent to setting an \\(L_1\\) or Lasso penalty on the changes -- hopefully sending them to 0 if they are unnecessary. Specifically we set \\[ v_k, w_k \\sim \\text{Laplace}(0, \\sigma_U), \\qquad \\text{for }k = 1, ..., K. \\]","title":"Unspecified changepoint events: \\(U(t)\\)"},{"location":"technical_description/#seasonality","text":"Similar to Prophet, we encode seasonality using Fourier series. The user defines the seasonal period \\(s_S\\), and the fourier period \\(s_F\\) (this is automatically set to \\(s_S - 1\\) if unspecified). Then seasonality is defined as \\[ s(t) = \\sum_{j=1}^{s_F} \\beta_j f_j(t), \\] where \\[ f_j(t) = \\mathbf 1\\{j \\text{mod} 2 = 0\\} \\cos\\left(\\frac{2 \\pi \\lfloor j / 2 \\rfloor t}{s_F}\\right) + \\mathbf 1\\{j \\text{mod} 2 = 1\\} \\sin\\left(\\frac{2 \\pi (\\lfloor j / 2 \\rfloor + 1) t}{s_F}\\right). \\] For each seasonal coefficient \\(\\beta_j\\), we set the prior \\[ \\beta_j \\sim N(0, \\sigma_s). \\]","title":"Seasonality"},{"location":"tutorials/Combined_Tutorials/","text":"How-to Tutorials The tutorial section is a more detailed explanation of the JudgyProphet functionality. It discusses how to model level events, trend events, and seasonality. It also gives a brief overview of hyperparameters settings. The tutorial is based on the jupyter notebools in the tutorial folder. Level Event In this tutorial we use judgyprophet to forecast a time series with what we call a level_event . It is a sudden change in level of the time series without an underlying trend change. An example would be the following: from judgyprophet.tutorials.resources import get_level_event example_data = get_level_event () example_data . plot . line () <AxesSubplot:> We can see a relatively stable constant trajectory, followed by a shift in that trajectory around April 2020. It is quite stable after that. The example above also shows the format of the data required by judgyprophet . The data should be a pandas Series , with the actuals as the entries, e.g.: 2019-01-01 3.287609 2019-02-01 4.753766 2019-03-01 3.955497 2019-04-01 4.451812 2019-05-01 5.345102 Freq: MS, dtype: float64 The index should denote the datetime element of the series, it should be ordered and have no gaps. It can either be a pandas index for specifically working with time series (e.g. pd.DatetimeIndex ), or just an integer based index \u2013 this means you don\u2019t have to explicitly list dates. If it is a pandas time series index, the freq should be set. This allows judgyprophet to calculate the horizon during prediction. In our case the freq is set to be \u2018MS\u2019, meaning month start. Format the level event expectation for JudgyProphet Suppose that we are aware in January 2020 that an event is likely to happen in April 2020 which will change the level by approximately 10. We would encode this in judgyprophet as follows: level_events = [ { 'name' : 'Expected event 1' , 'index' : '2020-04-01' , 'c0' : 10 } ] Each level event is encoded as a dict with two required entries: the 'index' field, which is the index in the data when the event occurs. If this entry is fed into example_data.loc[] , then it should return a single value. It follows the standard pandas indexing rules (for example, see here ). The 'c0' field is the initial estimate by the business of what the impact of this level event will be. It is fed into the model as an informative prior on the level event mean; which is then updated in a Bayesian way. Forecasting with JudgyProphet before the event occurs Now let\u2019s pretend we\u2019re still in January 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet # Cutoff the data to January 2020 data_jan2020 = example_data . loc [: \"2020-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2020 , level_events = level_events , trend_events = [], sigma_base_bias = .1 , sigma_base_trend = .1 , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Post-event data for level event Expected event 1 less than 0 points. Event deactivated in model. Event index: 2020-04-01, training data end index: 2019-01-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -56.9093 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 3 -25.5963 0.272471 1.08052e-14 1 1 6 Optimization terminated normally: Convergence detected: gradient norm is below tolerance Let\u2019s plot the results\u2026 import pandas as pd import seaborn as sns predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_jan2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-02-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> We can see from the plot that the forecast captures the event pretty well. However the business estimate of the change-in-level event is probably slightly too high; which leads to the forecast to slightly overshoot the actuals. Forecasting with JudgyProphet after the event occurs This is where the Bayesian updating comes into its own. Let\u2019s now fit the forecast after the event has occurred. At this point, the impact of the event will be updated in a Bayesian way given what has been seen in the actuals. # Cutoff the data to June 2020 data_june2020 = example_data . loc [: \"2020-06-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_june2020 , level_events = level_events , trend_events = [], sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding level event Expected event 1 to model. Event index: 2020-04-01, training data start index: 2019-01-01 00:00:00, training data end index: 2020-06-01 00:00:00. Initial level: 10. Initial log joint probability = -17.0116 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 6 -2.93197 1.93616e-05 3.23115e-06 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results again: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_june2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-07-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> When judgyprophet predicts after the event occurs, it decreases the business estimate as it observes actuals. Trend Events In this tutorial we use judgyprophet to forecast a time series with a known/expected change in trend. This is called a trend_event and an example would be the following: from judgyprophet.tutorials.resources import get_trend_event example_data = get_trend_event () example_data . plot . line () <AxesSubplot:> We can see from the plot that there is an uptick in trend around September 2020. Format the trend event expectation for JudgyProphet Suppose we are in April 2020, and we have the prior knowledge that an event will occur in September. The expected change of the trend gradient will be an uptick of 6. We can encode this in judgyprophet as an expected trend event as follows: trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : 6 } ] Each trend event is encoded as a dict with two required entries: the \u2018index\u2019 field, which is the index in the data when the event occurs. If this entry is fed into example_data.loc[], then it should return a single value. It follows the standard pandas indexing rules (for example, see here). The \u2018m0\u2019 field is the initial estimate by the business of what the impact of this event on the trend will be (e.g. in our case we estimate it will increase the trend by 6). It is fed into the model as an informative prior on the level event mean; which is then updated in a Bayesian way. Forecasting with JudgyProphet before the event occurs Now let\u2019s pretend we\u2019re still in April 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_apr2020 = example_data . loc [: \"2020-04-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_apr2020 , level_events = [], trend_events = trend_events , sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -17.6559 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 5 -2.70162 0.00625172 1.10466e-05 1 1 8 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Forecasting with JudgyProphet after the event occurs We can see that with the business information, the forecast is better able to handle the sudden uptick in trend. After a while though, we can see that the business estimate of the trend is an overestimate. Let\u2019s see if the Bayesian updating can account for this. We now suppose we are re-forecasting the product in January 2021. from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: 6. Damping: None. Initial log joint probability = -18.4007 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -1.64341 1.13818e-05 8.53133e-05 1 1 10 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [ predictions . index <= \"2021-06-01\" , [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Although the forecast is still a slight overestimate, the Bayesian updating has downgraded the initial estimate somewhat. Trend event reducing the historic trend A trend event can also reduce the previous trend. A common real world examples for this case are a competitor entering the market and thus over time reducing your products market share. example_data = get_trend_event ( uptake = False ) example_data . plot . line () <AxesSubplot:> Format the trend event expectation for JudgyProphet In this case, we simply add a minus to the expected trend impact: trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : - 6 } ] Forecasting with JudgyProphet before the event occurs Again, we\u2019re still in April 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_apr2020 = example_data . loc [: \"2020-04-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_apr2020 , level_events = [], trend_events = trend_events , sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -3.20978 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -2.70162 5.03247e-05 6.65978e-05 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Forecasting with JudgyProphet after the event occurs And after the event, we again learn from the additional data points: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: -6. Damping: None. Initial log joint probability = -28.0997 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 6 -7.46664 0.000740991 0.000446113 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [ predictions . index <= \"2021-06-01\" , [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Damping In real world examples, we often observe that the initial trend after the event changes over time. A good example is the total sales of a product if this product is released to an additional new market. In this scenario, there is usually a period of strong uptake initially, followed by a slowing of uptake as the market saturates. We model this in judgyprophet by using damping. The damping model is a linear trend with damping, which is the same as that used in one of the most popular exponential smoothing methods: Holt\u2019s linear damped trend (see here ). Unlike the trend and level parameters, the damping is set by the user, and is not learnt during fitting. This is because we found learning using Bayesian fitting to be inaccurate. If you are not sure what the damping term should be we recommend using cross-validation, or observing similar market launches. The damping term is usually between 0.8 and 1 (where 1 means no damping, i.e. a linear model), it is equivalent to the \\(\\phi\\) parameter in the description of Holt\u2019s linear damped trend. Those who know Prophet will remember it modelled this using logistic curves. We found this was extremely sensitive to the choice of the capacity parameter \\(C\\) (the population the new entrant would eventually reach). This is why we opted for the damped linear trend, which we found to be more flexible. Let\u2019s look at a curve with damping: from judgyprophet.tutorials.resources import get_damped_trend_event example_data = get_damped_trend_event () print ( example_data . head ()) example_data . plot . line () 2019-06-01 3.287609 2019-07-01 5.253766 2019-08-01 4.955497 2019-09-01 5.951812 2019-10-01 7.345102 Freq: MS, dtype: float64 <AxesSubplot:> We can see there is an initial uptick in trend, followed by a plateauing effect as the market saturates. Format the damped trend event expectation for JudgyProphet We talk to the business and they assume the initial trend uptake is 5, with a damping parameter from analysing similar market entrants of .9. We encode this as a trend_event as follows, notice that we refer to the damping parameter as gamma : trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2020-01-01' , 'm0' : 5 , 'gamma' : .85 } ] Forecasting with JudgyProphet before the event occurs from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_oct2019 = example_data . loc [: \"2019-10-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_oct2019 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_oct2019 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2019-10-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) WARNING:judgyprophet.utils:Arg 'data' has less than 5 data points. Expect a poor fit. INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New saturating market entry less than 0 points. Event deactivated in model. Event index: 2020-01-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -4.75577 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 4 -2.08579 0.0190169 7.99064e-06 1 1 6 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> We can see the initial estimates are quite off this time. This is because the business overestimated the damping and the trend. Let\u2019s see what happens as we start to observe actuals. Forecasting with JudgyProphet after the event occurs from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 cutoff = \"2020-04-01\" data_cutoff = example_data . loc [: cutoff ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_cutoff , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2020-01-01, training data start index: 2019-06-01 00:00:00, training data end index: 2020-04-01 00:00:00. Initial gradient: 5. Damping: 0.85. Initial log joint probability = -10.4473 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 9 -2.49061 8.76664e-05 0.00143778 0.9171 0.9171 11 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> While the trend is still a little overestimated, it is definitely improving. But is there anything we can do to improve the situation? Unspecified Changepoints Like prophet, we enable the user to include unspecified changepoints into the forecast. Unexpected changepoints enables us to handle unexpected changes in the trend of level of the time series. This is done by setting the unspecified_changepoints parameter in the fit method of JudgyProphet . Unspecified changepoints are initially set to have no effect on the model, but if actuals are observed that deviate from the model, they will be \u2018turned on,\u2019 and change the model. The arg unspecified_changepoints either takes an integer as input, which will intersperse the changepoints equally across time, or a list of indexes, which will place changepoints at exactly those time points. These changepoints are given a Laplace prior with a mean of 0, and a scale set by the arg sigma_unspecified_changepoints . The sigma_unspecified_changepoints affects the L1 penalty on the unspecified changepoints. Set sigma to be high (e.g. .5 or greater) and the unspecified changepoints will be very sensitive. Set it low (e.g. 0.05), and it will be insensitive. Unlike prophet, setting these changepoints does not change the prediction. Only level_events and trend_events in the prediction horizon will affect the forecast. Let\u2019s see what affect these have on the previous damping example\u2026 from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 cutoff = \"2020-04-01\" data_cutoff = example_data . loc [: cutoff ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_cutoff , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2020-01-01, training data start index: 2019-06-01 00:00:00, training data end index: 2020-04-01 00:00:00. Initial gradient: 5. Damping: 0.85. WARNING:judgyprophet.utils:Unspecified changepoint with index 2020-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. Initial log joint probability = -85.6424 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 12 -2.55807 0.00253247 10.5928 0.0002553 0.001 57 LS failed, Hessian reset 19 -2.53784 0.00129929 12.9114 2.828 0.4174 69 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -2.49159 1.88991e-05 13.7481 0.05264 1 106 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 43 -2.49059 2.07785e-05 13.316 1.762e-06 0.001 150 LS failed, Hessian reset 49 -2.48998 7.5683e-06 12.3042 6.778e-07 0.001 193 LS failed, Hessian reset 59 -2.48991 3.40412e-07 12.2862 0.3482 0.3482 210 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 70 -2.4899 8.88435e-09 11.2343 6.928e-10 0.001 271 LS failed, Hessian reset Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance /Users/kpxh622/github/judgyprophet/judgyprophet/utils.py:31: UserWarning: Unspecified changepoint with index 2020-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. warnings.warn(msg) <AxesSubplot:xlabel='ds', ylabel='value'> We can see in this case the unspecified changepoints have improved the model fit significantly. We recommend caution with unspecified changepoints though, they come with a cost, and when your time series is quite noisy they might be overreactive. In this case it is recommended to tune your sigma_unspecified_changepoints accordingly, or limit the amount of changepoints you use. Seasonality Similar to prophet , judgyprophet models seasonality as Fourier series and can handle both additive and multiplicative seasonality. However, the seasonality implementation is currently limited to the index frequency and does not support the split into weekly, monthly, and yearly. To enable seasonality, simply set the seasonal_period arg to a positive integer (e.g. 12 for monthly data, 7 for daily). The default seasonality is additive, to change this to multiplicative set the arg seasonal_type to be 'mult' . The Fourier order is set via the fourier_order parameter, with the default value set to seasonal_period - 1. The Fourier order determines how quickly the seasonality can change and the reducing order compared to the default parameters might help to avoid overfitting. Additive Seasonality In the case of additive seasonality, the amplitude of the seasonal variation is independent of the trend and is hence roughly constant over the time series. If additive seasonality is selected, judgyprophet will rescale the time series onto zero mean and standard variance. An example is shown here: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns from judgyprophet.tutorials.resources import get_additive_seasonality_linear_trend example_data = get_additive_seasonality_linear_trend () # Cutoff the data to October 2020 cutoff = \"2020-10-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We are passing in a simple time series without trend or level events. The seasonality is set to 12 # and the seasonality component is simply additive. jp . fit ( data = data_cutoff , level_events = [], trend_events = [], seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 12 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -891.479 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -1.34039 1.12595e-05 0.00168501 0.5461 0.5461 30 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 21 -1.34039 1.01095e-06 0.00067455 0.1367 0.9362 33 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Multiplicative Seasonality In case of multiplicative seasonality, the seasonal variations are changing proportional to the level of the series. If multiplicative seasonality is selected, judgyprophet will rescale the time series by shifting all values positive with standard variance. An example is shown here: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns from judgyprophet.tutorials.resources import get_multiplicative_seasonality_linear_trend example_data = get_multiplicative_seasonality_linear_trend () # Cutoff the data to October 2020 cutoff = \"2020-10-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # The multiplicative example time series has a constant trend component, but the seasonality # is multiplicative and has a large amplitude. Again the period is set to 12. jp . fit ( data = data_cutoff , level_events = [], trend_events = [], seasonal_period = 12 , seasonal_type = \"mult\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 12 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling by shifting all values positive with 1-sd. WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -775.468 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -105.965 0.0490619 1203.53 0.04941 1 32 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -12.2029 0.0634662 440.207 0.1485 0.1485 64 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -0.683534 0.0372809 68.3501 1 1 84 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -0.454028 0.00336031 7.70556 0.8053 0.8053 109 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -0.442297 0.000894112 6.38619 0.006837 1 134 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -0.402061 0.0581892 7.15489 0.5184 1 159 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -0.287525 0.0223029 0.741186 1 1 187 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -0.285187 0.000493407 1.35585 0.3357 1 213 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -0.285081 5.78588e-05 0.106578 0.2866 0.02866 238 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -0.28508 6.70665e-06 0.00713309 0.1648 0.1648 259 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 206 -0.28508 1.07542e-05 0.00613299 1 1 267 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Combining Seasonality with Events Both seasonality can be combined with trend events, damping, level events, and unspecified changepoints. We will now walk through an example time series which contains a damped trend event and shows additive seasonality. Let\u2019s look at the data: from judgyprophet.tutorials.resources import get_additive_seasonal_damped_trend_event example_data = get_additive_seasonal_damped_trend_event () example_data . plot . line () <AxesSubplot:> We can see from the plot that there is an uptick in trend around January 2018. The uptick in trend is quite steep until the end of 2019 where we observe stronger damping. We also see that the time series has a seasonal pattern, with a seasonal_period of 12 and a peak in December each year. Forecasting with JudgyProphet before the event occurs The estimate of the trend event is a trend increase of 6 with a damping parameter of 0.9. from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 6 , 'gamma' : .9 } ] # Cutoff the data to June 2017 cutoff = \"2017-06-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New saturating market entry less than 0 points. Event deactivated in model. Event index: 2018-01-01, training data end index: 2015-01-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -5618.69 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -19.5311 0.107624 53.5313 1 1 25 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -14.4873 0.00450173 32.1225 1 1 54 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -11.3416 0.0164259 63.5553 0.1261 1 83 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -10.031 0.00192964 42.0027 0.4045 0.4045 111 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -9.91568 0.00123052 20.6714 0.3407 1 136 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -9.74583 0.0178502 45.6554 1 1 161 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -9.58822 0.00240934 24.5607 0.1831 1 185 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -9.55939 0.000174537 18.265 1 1 214 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -9.55721 4.74996e-06 18.6232 1 1 243 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -9.55707 1.07478e-05 21.7289 1 1 267 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 219 -9.5541 1.0315e-05 21.3723 1 1 288 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 239 -9.50413 0.00075237 20.6816 0.6394 0.6394 309 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 259 -9.41589 0.000411908 21.7004 1 1 331 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 279 -9.39884 1.20103e-05 20.8879 0.3439 0.3439 355 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 299 -9.39799 4.26641e-06 20.0502 0.476 0.476 379 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 319 -9.37685 5.71275e-05 19.885 0.3824 0.3824 405 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 339 -9.34918 0.000126588 18.6708 0.9182 0.9182 429 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 359 -9.34728 1.3233e-05 20.7019 1 1 455 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 379 -9.33447 2.78134e-05 20.1768 0.5231 0.5231 477 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 399 -9.33284 2.29302e-06 20.0762 0.6157 0.6157 501 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 419 -9.33248 1.2898e-05 19.1065 0.08486 1 529 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 420 -9.33247 3.42574e-06 21.2674 1.793e-07 0.001 576 LS failed, Hessian reset 439 -9.33237 2.57199e-07 22.0328 0.3448 1 603 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 450 -9.33237 7.89272e-09 20.4987 0.2986 1 621 Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Forecasting with JudgyProphet after the event occurs We can see that the model picks up correctly the seasonal pattern and incorporates the trend event. After a few more data points are observed, the model learned that the initial trend event estimates were poorly and corrects its forecast accordingly. Let\u2019s look at the forecast repeated in June 2018: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 6 , 'gamma' : .9 } ] # Cutoff the data to June 2017 cutoff = \"2018-06-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-06-01 00:00:00. Initial gradient: 6. Damping: 0.9. WARNING:judgyprophet.utils:Unspecified changepoint with index 2018-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. Initial log joint probability = -4219.81 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -45.4011 0.0443425 326.047 1 1 26 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -15.3423 0.00201394 41.5814 1 1 53 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -11.4289 0.0222713 70.3068 1 1 82 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -9.74468 0.0019911 38.3992 0.8659 0.8659 110 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -9.55453 0.00466659 25.2859 0.949 0.949 137 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -9.42124 0.000328639 21.1329 0.3671 1 163 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -9.38936 0.00514148 27.2595 1 1 196 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -9.3399 0.00760439 37.8239 1 1 223 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -9.27552 0.000532321 24.6411 0.4927 0.4927 247 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -9.23377 0.00261612 16.9745 0.8399 0.8399 269 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 202 -9.23013 0.000104263 18.2691 5.753e-06 0.001 364 LS failed, Hessian reset 219 -9.19983 0.00127842 29.8317 1 1 381 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 239 -9.16268 0.00026094 21.9496 3.298 0.3298 403 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 259 -9.1381 0.00160896 29.4252 0.9121 0.9121 426 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 279 -9.11448 0.000430079 17.2828 1 1 451 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 299 -9.09913 0.000132984 15.3301 0.2225 0.2225 479 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 319 -9.09577 7.96264e-05 20.5328 0.9646 0.9646 507 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 339 -9.0927 5.35475e-06 18.2672 0.38 1 533 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 359 -9.09266 1.83214e-08 16.0514 1 1 567 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 365 -9.09266 6.04342e-09 18.2719 0.6683 0.6683 573 Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance /Users/kpxh622/github/judgyprophet/judgyprophet/utils.py:31: UserWarning: Unspecified changepoint with index 2018-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. warnings.warn(msg) <AxesSubplot:xlabel='ds', ylabel='value'> Hyperparameters judgyprophet gives full control over hyperparameters. These are mainly scale parameters which determine how sensitive judgyprophet is to actuals. The most useful of these are: sigma_level \u2013 each level event is assigned a Normal prior with mean the business estimate (\u2018c0\u2019), and standard deviation is set to this arg. The lower this is, the closer the event will follow the business suggestions \u2013 its default is 0.1. sigma_trend \u2013 each trend event is assigned a Normal prior with mean the business estimate (\u2018m0\u2019), and standard deviation is set to this arg. The lower this is, the closer the event will follow the business suggestions \u2013 its default is 0.1. sigma_unspecified_changepoints \u2013 each unspecified changepoint is assigned a Laplace prior (equivalent to L1 penalty) with mean 0, and standard deviation set to this arg. The lower this is, the less likely the model will use this changepoint. Other hyperparameters are: sigma_base_bias \u2013 the initial bias is assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. sigma_base_trend \u2013 the initial trend is assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. sigma_seasonal \u2013 the seasonality parameters are assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. Example of Hyperparameter impact The default hyperparameter values for judgyprophet tend to deliver reasonable estimations. However, there might be situations in which you would like to adjust those to pay more or less attention to prior knowledge. Values between 1 and 0.01 seem to deliver quite stable results. We will now adjusting the prior for the trend event to understand the hyperparameter impact. Let\u2019s load again the time series which contains a damped trend event and additive seasonality which we saw in the Seasonality tutorial. This time, we added some correlated noise after the trend event happened (between April and August 2018): from judgyprophet.tutorials.resources import get_additive_seasonal_damped_trend_event_correlated_noise example_data = get_additive_seasonal_damped_trend_event_correlated_noise () example_data . plot . line () <AxesSubplot:> The trend event parameters in this case are the exact solution to trend shown in the above time series: trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 9 , 'gamma' : .9 } ] Forecasting with the default hyperparameters We are now creating a forecast in July 2017. Using the default value for sigma_trend creates the following forecast: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-08-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-08-01 00:00:00. Initial gradient: 9. Damping: 0.9. Initial log joint probability = -1125.09 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 17 -24.2744 0.000161304 0.00638672 1 1 31 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Nevertheless, the default hyperparameter tend to underestimate the impact of the trend event: Since the model is learning from the previously observed data points (which contain the correlated noise), the model assumes that the prior trend event estimates were inaccurate and it corrects the estimated trend downwards. Testing a very low sigma_trend value If we are certain that our prior knowledge is correct and we assume a high volatility in our time series, we can reduce the prior value for sigma_trend . That will encourge the model to strictly follow initial trend event estimations given to it. In this case, adjusting the hyperparameter value can improve our forecast accuracy: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-08-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.01 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-08-01 00:00:00. Initial gradient: 9. Damping: 0.9. Initial log joint probability = -1191.51 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -42.6551 0.0255416 21.9616 1 1 25 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -40.5184 0.0027457 2.62096 1 1 51 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -40.4754 0.000243228 0.568846 1 1 74 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -40.474 0.000184754 0.147366 1 1 99 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 97 -40.474 6.17252e-05 0.0258339 1 1 121 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Testing a very high sigma_trend value If you are not certain if your estimations are correct prior to the event, it is sensible to assign a higher value to the sigma_trend parameter. This is beneficial in situations where our prior estimations are poorly. Let\u2019s look at the forecast created in November 2018: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-11-01\" data_cutoff = example_data . loc [: cutoff ] poor_trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 1 , 'gamma' : .9 } ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 10 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = poor_trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-11-01 00:00:00. Initial gradient: 1. Damping: 0.9. Initial log joint probability = -962.005 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -16.6821 0.000169582 0.22355 1 1 27 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -16.682 0.000103557 0.0974231 1 1 50 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -16.682 5.07955e-06 0.0182171 0.1133 1 78 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> The model with a large prior for simga_trend learned that the prior trend event estimates underestimated the trend change, and adjusted its forecast accordingly, whereas the default value would produce a larger forecasting error: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-11-01\" data_cutoff = example_data . loc [: cutoff ] poor_trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 1 , 'gamma' : .9 } ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = poor_trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-11-01 00:00:00. Initial gradient: 1. Damping: 0.9. Initial log joint probability = -979.779 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -21.5681 0.000488491 0.799235 1 1 27 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 38 -21.5671 6.15078e-05 0.00396993 1.018 0.1018 65 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Combined Tutorials"},{"location":"tutorials/Combined_Tutorials/#how-to-tutorials","text":"The tutorial section is a more detailed explanation of the JudgyProphet functionality. It discusses how to model level events, trend events, and seasonality. It also gives a brief overview of hyperparameters settings. The tutorial is based on the jupyter notebools in the tutorial folder.","title":"How-to Tutorials"},{"location":"tutorials/Combined_Tutorials/#level-event","text":"In this tutorial we use judgyprophet to forecast a time series with what we call a level_event . It is a sudden change in level of the time series without an underlying trend change. An example would be the following: from judgyprophet.tutorials.resources import get_level_event example_data = get_level_event () example_data . plot . line () <AxesSubplot:> We can see a relatively stable constant trajectory, followed by a shift in that trajectory around April 2020. It is quite stable after that. The example above also shows the format of the data required by judgyprophet . The data should be a pandas Series , with the actuals as the entries, e.g.: 2019-01-01 3.287609 2019-02-01 4.753766 2019-03-01 3.955497 2019-04-01 4.451812 2019-05-01 5.345102 Freq: MS, dtype: float64 The index should denote the datetime element of the series, it should be ordered and have no gaps. It can either be a pandas index for specifically working with time series (e.g. pd.DatetimeIndex ), or just an integer based index \u2013 this means you don\u2019t have to explicitly list dates. If it is a pandas time series index, the freq should be set. This allows judgyprophet to calculate the horizon during prediction. In our case the freq is set to be \u2018MS\u2019, meaning month start.","title":"Level Event"},{"location":"tutorials/Combined_Tutorials/#format-the-level-event-expectation-for-judgyprophet","text":"Suppose that we are aware in January 2020 that an event is likely to happen in April 2020 which will change the level by approximately 10. We would encode this in judgyprophet as follows: level_events = [ { 'name' : 'Expected event 1' , 'index' : '2020-04-01' , 'c0' : 10 } ] Each level event is encoded as a dict with two required entries: the 'index' field, which is the index in the data when the event occurs. If this entry is fed into example_data.loc[] , then it should return a single value. It follows the standard pandas indexing rules (for example, see here ). The 'c0' field is the initial estimate by the business of what the impact of this level event will be. It is fed into the model as an informative prior on the level event mean; which is then updated in a Bayesian way.","title":"Format the level event expectation for JudgyProphet"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-before-the-event-occurs","text":"Now let\u2019s pretend we\u2019re still in January 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet # Cutoff the data to January 2020 data_jan2020 = example_data . loc [: \"2020-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2020 , level_events = level_events , trend_events = [], sigma_base_bias = .1 , sigma_base_trend = .1 , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Post-event data for level event Expected event 1 less than 0 points. Event deactivated in model. Event index: 2020-04-01, training data end index: 2019-01-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -56.9093 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 3 -25.5963 0.272471 1.08052e-14 1 1 6 Optimization terminated normally: Convergence detected: gradient norm is below tolerance Let\u2019s plot the results\u2026 import pandas as pd import seaborn as sns predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_jan2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-02-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> We can see from the plot that the forecast captures the event pretty well. However the business estimate of the change-in-level event is probably slightly too high; which leads to the forecast to slightly overshoot the actuals.","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-after-the-event-occurs","text":"This is where the Bayesian updating comes into its own. Let\u2019s now fit the forecast after the event has occurred. At this point, the impact of the event will be updated in a Bayesian way given what has been seen in the actuals. # Cutoff the data to June 2020 data_june2020 = example_data . loc [: \"2020-06-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_june2020 , level_events = level_events , trend_events = [], sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding level event Expected event 1 to model. Event index: 2020-04-01, training data start index: 2019-01-01 00:00:00, training data end index: 2020-06-01 00:00:00. Initial level: 10. Initial log joint probability = -17.0116 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 6 -2.93197 1.93616e-05 3.23115e-06 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results again: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_june2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-07-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> When judgyprophet predicts after the event occurs, it decreases the business estimate as it observes actuals.","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/Combined_Tutorials/#trend-events","text":"In this tutorial we use judgyprophet to forecast a time series with a known/expected change in trend. This is called a trend_event and an example would be the following: from judgyprophet.tutorials.resources import get_trend_event example_data = get_trend_event () example_data . plot . line () <AxesSubplot:> We can see from the plot that there is an uptick in trend around September 2020.","title":"Trend Events"},{"location":"tutorials/Combined_Tutorials/#format-the-trend-event-expectation-for-judgyprophet","text":"Suppose we are in April 2020, and we have the prior knowledge that an event will occur in September. The expected change of the trend gradient will be an uptick of 6. We can encode this in judgyprophet as an expected trend event as follows: trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : 6 } ] Each trend event is encoded as a dict with two required entries: the \u2018index\u2019 field, which is the index in the data when the event occurs. If this entry is fed into example_data.loc[], then it should return a single value. It follows the standard pandas indexing rules (for example, see here). The \u2018m0\u2019 field is the initial estimate by the business of what the impact of this event on the trend will be (e.g. in our case we estimate it will increase the trend by 6). It is fed into the model as an informative prior on the level event mean; which is then updated in a Bayesian way.","title":"Format the trend event expectation for JudgyProphet"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-before-the-event-occurs_1","text":"Now let\u2019s pretend we\u2019re still in April 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_apr2020 = example_data . loc [: \"2020-04-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_apr2020 , level_events = [], trend_events = trend_events , sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -17.6559 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 5 -2.70162 0.00625172 1.10466e-05 1 1 8 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-after-the-event-occurs_1","text":"We can see that with the business information, the forecast is better able to handle the sudden uptick in trend. After a while though, we can see that the business estimate of the trend is an overestimate. Let\u2019s see if the Bayesian updating can account for this. We now suppose we are re-forecasting the product in January 2021. from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: 6. Damping: None. Initial log joint probability = -18.4007 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -1.64341 1.13818e-05 8.53133e-05 1 1 10 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [ predictions . index <= \"2021-06-01\" , [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Although the forecast is still a slight overestimate, the Bayesian updating has downgraded the initial estimate somewhat.","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/Combined_Tutorials/#trend-event-reducing-the-historic-trend","text":"A trend event can also reduce the previous trend. A common real world examples for this case are a competitor entering the market and thus over time reducing your products market share. example_data = get_trend_event ( uptake = False ) example_data . plot . line () <AxesSubplot:>","title":"Trend event reducing the historic trend"},{"location":"tutorials/Combined_Tutorials/#format-the-trend-event-expectation-for-judgyprophet_1","text":"In this case, we simply add a minus to the expected trend impact: trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : - 6 } ]","title":"Format the trend event expectation for JudgyProphet"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-before-the-event-occurs_2","text":"Again, we\u2019re still in April 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_apr2020 = example_data . loc [: \"2020-04-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_apr2020 , level_events = [], trend_events = trend_events , sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -3.20978 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -2.70162 5.03247e-05 6.65978e-05 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-after-the-event-occurs_2","text":"And after the event, we again learn from the additional data points: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: -6. Damping: None. Initial log joint probability = -28.0997 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 6 -7.46664 0.000740991 0.000446113 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [ predictions . index <= \"2021-06-01\" , [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/Combined_Tutorials/#damping","text":"In real world examples, we often observe that the initial trend after the event changes over time. A good example is the total sales of a product if this product is released to an additional new market. In this scenario, there is usually a period of strong uptake initially, followed by a slowing of uptake as the market saturates. We model this in judgyprophet by using damping. The damping model is a linear trend with damping, which is the same as that used in one of the most popular exponential smoothing methods: Holt\u2019s linear damped trend (see here ). Unlike the trend and level parameters, the damping is set by the user, and is not learnt during fitting. This is because we found learning using Bayesian fitting to be inaccurate. If you are not sure what the damping term should be we recommend using cross-validation, or observing similar market launches. The damping term is usually between 0.8 and 1 (where 1 means no damping, i.e. a linear model), it is equivalent to the \\(\\phi\\) parameter in the description of Holt\u2019s linear damped trend. Those who know Prophet will remember it modelled this using logistic curves. We found this was extremely sensitive to the choice of the capacity parameter \\(C\\) (the population the new entrant would eventually reach). This is why we opted for the damped linear trend, which we found to be more flexible. Let\u2019s look at a curve with damping: from judgyprophet.tutorials.resources import get_damped_trend_event example_data = get_damped_trend_event () print ( example_data . head ()) example_data . plot . line () 2019-06-01 3.287609 2019-07-01 5.253766 2019-08-01 4.955497 2019-09-01 5.951812 2019-10-01 7.345102 Freq: MS, dtype: float64 <AxesSubplot:> We can see there is an initial uptick in trend, followed by a plateauing effect as the market saturates.","title":"Damping"},{"location":"tutorials/Combined_Tutorials/#format-the-damped-trend-event-expectation-for-judgyprophet","text":"We talk to the business and they assume the initial trend uptake is 5, with a damping parameter from analysing similar market entrants of .9. We encode this as a trend_event as follows, notice that we refer to the damping parameter as gamma : trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2020-01-01' , 'm0' : 5 , 'gamma' : .85 } ]","title":"Format the damped trend event expectation for JudgyProphet"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-before-the-event-occurs_3","text":"from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_oct2019 = example_data . loc [: \"2019-10-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_oct2019 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_oct2019 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2019-10-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) WARNING:judgyprophet.utils:Arg 'data' has less than 5 data points. Expect a poor fit. INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New saturating market entry less than 0 points. Event deactivated in model. Event index: 2020-01-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -4.75577 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 4 -2.08579 0.0190169 7.99064e-06 1 1 6 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> We can see the initial estimates are quite off this time. This is because the business overestimated the damping and the trend. Let\u2019s see what happens as we start to observe actuals.","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-after-the-event-occurs_3","text":"from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 cutoff = \"2020-04-01\" data_cutoff = example_data . loc [: cutoff ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_cutoff , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2020-01-01, training data start index: 2019-06-01 00:00:00, training data end index: 2020-04-01 00:00:00. Initial gradient: 5. Damping: 0.85. Initial log joint probability = -10.4473 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 9 -2.49061 8.76664e-05 0.00143778 0.9171 0.9171 11 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> While the trend is still a little overestimated, it is definitely improving. But is there anything we can do to improve the situation?","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/Combined_Tutorials/#unspecified-changepoints","text":"Like prophet, we enable the user to include unspecified changepoints into the forecast. Unexpected changepoints enables us to handle unexpected changes in the trend of level of the time series. This is done by setting the unspecified_changepoints parameter in the fit method of JudgyProphet . Unspecified changepoints are initially set to have no effect on the model, but if actuals are observed that deviate from the model, they will be \u2018turned on,\u2019 and change the model. The arg unspecified_changepoints either takes an integer as input, which will intersperse the changepoints equally across time, or a list of indexes, which will place changepoints at exactly those time points. These changepoints are given a Laplace prior with a mean of 0, and a scale set by the arg sigma_unspecified_changepoints . The sigma_unspecified_changepoints affects the L1 penalty on the unspecified changepoints. Set sigma to be high (e.g. .5 or greater) and the unspecified changepoints will be very sensitive. Set it low (e.g. 0.05), and it will be insensitive. Unlike prophet, setting these changepoints does not change the prediction. Only level_events and trend_events in the prediction horizon will affect the forecast. Let\u2019s see what affect these have on the previous damping example\u2026 from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 cutoff = \"2020-04-01\" data_cutoff = example_data . loc [: cutoff ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_cutoff , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2020-01-01, training data start index: 2019-06-01 00:00:00, training data end index: 2020-04-01 00:00:00. Initial gradient: 5. Damping: 0.85. WARNING:judgyprophet.utils:Unspecified changepoint with index 2020-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. Initial log joint probability = -85.6424 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 12 -2.55807 0.00253247 10.5928 0.0002553 0.001 57 LS failed, Hessian reset 19 -2.53784 0.00129929 12.9114 2.828 0.4174 69 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -2.49159 1.88991e-05 13.7481 0.05264 1 106 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 43 -2.49059 2.07785e-05 13.316 1.762e-06 0.001 150 LS failed, Hessian reset 49 -2.48998 7.5683e-06 12.3042 6.778e-07 0.001 193 LS failed, Hessian reset 59 -2.48991 3.40412e-07 12.2862 0.3482 0.3482 210 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 70 -2.4899 8.88435e-09 11.2343 6.928e-10 0.001 271 LS failed, Hessian reset Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance /Users/kpxh622/github/judgyprophet/judgyprophet/utils.py:31: UserWarning: Unspecified changepoint with index 2020-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. warnings.warn(msg) <AxesSubplot:xlabel='ds', ylabel='value'> We can see in this case the unspecified changepoints have improved the model fit significantly. We recommend caution with unspecified changepoints though, they come with a cost, and when your time series is quite noisy they might be overreactive. In this case it is recommended to tune your sigma_unspecified_changepoints accordingly, or limit the amount of changepoints you use.","title":"Unspecified Changepoints"},{"location":"tutorials/Combined_Tutorials/#seasonality","text":"Similar to prophet , judgyprophet models seasonality as Fourier series and can handle both additive and multiplicative seasonality. However, the seasonality implementation is currently limited to the index frequency and does not support the split into weekly, monthly, and yearly. To enable seasonality, simply set the seasonal_period arg to a positive integer (e.g. 12 for monthly data, 7 for daily). The default seasonality is additive, to change this to multiplicative set the arg seasonal_type to be 'mult' . The Fourier order is set via the fourier_order parameter, with the default value set to seasonal_period - 1. The Fourier order determines how quickly the seasonality can change and the reducing order compared to the default parameters might help to avoid overfitting.","title":"Seasonality"},{"location":"tutorials/Combined_Tutorials/#additive-seasonality","text":"In the case of additive seasonality, the amplitude of the seasonal variation is independent of the trend and is hence roughly constant over the time series. If additive seasonality is selected, judgyprophet will rescale the time series onto zero mean and standard variance. An example is shown here: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns from judgyprophet.tutorials.resources import get_additive_seasonality_linear_trend example_data = get_additive_seasonality_linear_trend () # Cutoff the data to October 2020 cutoff = \"2020-10-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We are passing in a simple time series without trend or level events. The seasonality is set to 12 # and the seasonality component is simply additive. jp . fit ( data = data_cutoff , level_events = [], trend_events = [], seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 12 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -891.479 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -1.34039 1.12595e-05 0.00168501 0.5461 0.5461 30 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 21 -1.34039 1.01095e-06 0.00067455 0.1367 0.9362 33 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Additive Seasonality"},{"location":"tutorials/Combined_Tutorials/#multiplicative-seasonality","text":"In case of multiplicative seasonality, the seasonal variations are changing proportional to the level of the series. If multiplicative seasonality is selected, judgyprophet will rescale the time series by shifting all values positive with standard variance. An example is shown here: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns from judgyprophet.tutorials.resources import get_multiplicative_seasonality_linear_trend example_data = get_multiplicative_seasonality_linear_trend () # Cutoff the data to October 2020 cutoff = \"2020-10-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # The multiplicative example time series has a constant trend component, but the seasonality # is multiplicative and has a large amplitude. Again the period is set to 12. jp . fit ( data = data_cutoff , level_events = [], trend_events = [], seasonal_period = 12 , seasonal_type = \"mult\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 12 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling by shifting all values positive with 1-sd. WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -775.468 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -105.965 0.0490619 1203.53 0.04941 1 32 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -12.2029 0.0634662 440.207 0.1485 0.1485 64 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -0.683534 0.0372809 68.3501 1 1 84 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -0.454028 0.00336031 7.70556 0.8053 0.8053 109 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -0.442297 0.000894112 6.38619 0.006837 1 134 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -0.402061 0.0581892 7.15489 0.5184 1 159 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -0.287525 0.0223029 0.741186 1 1 187 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -0.285187 0.000493407 1.35585 0.3357 1 213 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -0.285081 5.78588e-05 0.106578 0.2866 0.02866 238 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -0.28508 6.70665e-06 0.00713309 0.1648 0.1648 259 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 206 -0.28508 1.07542e-05 0.00613299 1 1 267 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Multiplicative Seasonality"},{"location":"tutorials/Combined_Tutorials/#combining-seasonality-with-events","text":"Both seasonality can be combined with trend events, damping, level events, and unspecified changepoints. We will now walk through an example time series which contains a damped trend event and shows additive seasonality. Let\u2019s look at the data: from judgyprophet.tutorials.resources import get_additive_seasonal_damped_trend_event example_data = get_additive_seasonal_damped_trend_event () example_data . plot . line () <AxesSubplot:> We can see from the plot that there is an uptick in trend around January 2018. The uptick in trend is quite steep until the end of 2019 where we observe stronger damping. We also see that the time series has a seasonal pattern, with a seasonal_period of 12 and a peak in December each year.","title":"Combining Seasonality with Events"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-before-the-event-occurs_4","text":"The estimate of the trend event is a trend increase of 6 with a damping parameter of 0.9. from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 6 , 'gamma' : .9 } ] # Cutoff the data to June 2017 cutoff = \"2017-06-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New saturating market entry less than 0 points. Event deactivated in model. Event index: 2018-01-01, training data end index: 2015-01-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -5618.69 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -19.5311 0.107624 53.5313 1 1 25 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -14.4873 0.00450173 32.1225 1 1 54 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -11.3416 0.0164259 63.5553 0.1261 1 83 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -10.031 0.00192964 42.0027 0.4045 0.4045 111 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -9.91568 0.00123052 20.6714 0.3407 1 136 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -9.74583 0.0178502 45.6554 1 1 161 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -9.58822 0.00240934 24.5607 0.1831 1 185 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -9.55939 0.000174537 18.265 1 1 214 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -9.55721 4.74996e-06 18.6232 1 1 243 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -9.55707 1.07478e-05 21.7289 1 1 267 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 219 -9.5541 1.0315e-05 21.3723 1 1 288 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 239 -9.50413 0.00075237 20.6816 0.6394 0.6394 309 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 259 -9.41589 0.000411908 21.7004 1 1 331 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 279 -9.39884 1.20103e-05 20.8879 0.3439 0.3439 355 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 299 -9.39799 4.26641e-06 20.0502 0.476 0.476 379 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 319 -9.37685 5.71275e-05 19.885 0.3824 0.3824 405 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 339 -9.34918 0.000126588 18.6708 0.9182 0.9182 429 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 359 -9.34728 1.3233e-05 20.7019 1 1 455 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 379 -9.33447 2.78134e-05 20.1768 0.5231 0.5231 477 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 399 -9.33284 2.29302e-06 20.0762 0.6157 0.6157 501 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 419 -9.33248 1.2898e-05 19.1065 0.08486 1 529 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 420 -9.33247 3.42574e-06 21.2674 1.793e-07 0.001 576 LS failed, Hessian reset 439 -9.33237 2.57199e-07 22.0328 0.3448 1 603 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 450 -9.33237 7.89272e-09 20.4987 0.2986 1 621 Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-judgyprophet-after-the-event-occurs_4","text":"We can see that the model picks up correctly the seasonal pattern and incorporates the trend event. After a few more data points are observed, the model learned that the initial trend event estimates were poorly and corrects its forecast accordingly. Let\u2019s look at the forecast repeated in June 2018: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 6 , 'gamma' : .9 } ] # Cutoff the data to June 2017 cutoff = \"2018-06-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-06-01 00:00:00. Initial gradient: 6. Damping: 0.9. WARNING:judgyprophet.utils:Unspecified changepoint with index 2018-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. Initial log joint probability = -4219.81 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -45.4011 0.0443425 326.047 1 1 26 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -15.3423 0.00201394 41.5814 1 1 53 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -11.4289 0.0222713 70.3068 1 1 82 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -9.74468 0.0019911 38.3992 0.8659 0.8659 110 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -9.55453 0.00466659 25.2859 0.949 0.949 137 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -9.42124 0.000328639 21.1329 0.3671 1 163 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -9.38936 0.00514148 27.2595 1 1 196 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -9.3399 0.00760439 37.8239 1 1 223 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -9.27552 0.000532321 24.6411 0.4927 0.4927 247 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -9.23377 0.00261612 16.9745 0.8399 0.8399 269 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 202 -9.23013 0.000104263 18.2691 5.753e-06 0.001 364 LS failed, Hessian reset 219 -9.19983 0.00127842 29.8317 1 1 381 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 239 -9.16268 0.00026094 21.9496 3.298 0.3298 403 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 259 -9.1381 0.00160896 29.4252 0.9121 0.9121 426 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 279 -9.11448 0.000430079 17.2828 1 1 451 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 299 -9.09913 0.000132984 15.3301 0.2225 0.2225 479 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 319 -9.09577 7.96264e-05 20.5328 0.9646 0.9646 507 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 339 -9.0927 5.35475e-06 18.2672 0.38 1 533 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 359 -9.09266 1.83214e-08 16.0514 1 1 567 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 365 -9.09266 6.04342e-09 18.2719 0.6683 0.6683 573 Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance /Users/kpxh622/github/judgyprophet/judgyprophet/utils.py:31: UserWarning: Unspecified changepoint with index 2018-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. warnings.warn(msg) <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/Combined_Tutorials/#hyperparameters","text":"judgyprophet gives full control over hyperparameters. These are mainly scale parameters which determine how sensitive judgyprophet is to actuals. The most useful of these are: sigma_level \u2013 each level event is assigned a Normal prior with mean the business estimate (\u2018c0\u2019), and standard deviation is set to this arg. The lower this is, the closer the event will follow the business suggestions \u2013 its default is 0.1. sigma_trend \u2013 each trend event is assigned a Normal prior with mean the business estimate (\u2018m0\u2019), and standard deviation is set to this arg. The lower this is, the closer the event will follow the business suggestions \u2013 its default is 0.1. sigma_unspecified_changepoints \u2013 each unspecified changepoint is assigned a Laplace prior (equivalent to L1 penalty) with mean 0, and standard deviation set to this arg. The lower this is, the less likely the model will use this changepoint. Other hyperparameters are: sigma_base_bias \u2013 the initial bias is assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. sigma_base_trend \u2013 the initial trend is assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. sigma_seasonal \u2013 the seasonality parameters are assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1.","title":"Hyperparameters"},{"location":"tutorials/Combined_Tutorials/#example-of-hyperparameter-impact","text":"The default hyperparameter values for judgyprophet tend to deliver reasonable estimations. However, there might be situations in which you would like to adjust those to pay more or less attention to prior knowledge. Values between 1 and 0.01 seem to deliver quite stable results. We will now adjusting the prior for the trend event to understand the hyperparameter impact. Let\u2019s load again the time series which contains a damped trend event and additive seasonality which we saw in the Seasonality tutorial. This time, we added some correlated noise after the trend event happened (between April and August 2018): from judgyprophet.tutorials.resources import get_additive_seasonal_damped_trend_event_correlated_noise example_data = get_additive_seasonal_damped_trend_event_correlated_noise () example_data . plot . line () <AxesSubplot:> The trend event parameters in this case are the exact solution to trend shown in the above time series: trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 9 , 'gamma' : .9 } ]","title":"Example of Hyperparameter impact"},{"location":"tutorials/Combined_Tutorials/#forecasting-with-the-default-hyperparameters","text":"We are now creating a forecast in July 2017. Using the default value for sigma_trend creates the following forecast: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-08-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-08-01 00:00:00. Initial gradient: 9. Damping: 0.9. Initial log joint probability = -1125.09 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 17 -24.2744 0.000161304 0.00638672 1 1 31 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Nevertheless, the default hyperparameter tend to underestimate the impact of the trend event: Since the model is learning from the previously observed data points (which contain the correlated noise), the model assumes that the prior trend event estimates were inaccurate and it corrects the estimated trend downwards.","title":"Forecasting with the default hyperparameters"},{"location":"tutorials/Combined_Tutorials/#testing-a-very-low-sigma_trend-value","text":"If we are certain that our prior knowledge is correct and we assume a high volatility in our time series, we can reduce the prior value for sigma_trend . That will encourge the model to strictly follow initial trend event estimations given to it. In this case, adjusting the hyperparameter value can improve our forecast accuracy: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-08-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.01 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-08-01 00:00:00. Initial gradient: 9. Damping: 0.9. Initial log joint probability = -1191.51 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -42.6551 0.0255416 21.9616 1 1 25 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -40.5184 0.0027457 2.62096 1 1 51 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -40.4754 0.000243228 0.568846 1 1 74 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -40.474 0.000184754 0.147366 1 1 99 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 97 -40.474 6.17252e-05 0.0258339 1 1 121 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Testing a very low sigma_trend value"},{"location":"tutorials/Combined_Tutorials/#testing-a-very-high-sigma_trend-value","text":"If you are not certain if your estimations are correct prior to the event, it is sensible to assign a higher value to the sigma_trend parameter. This is beneficial in situations where our prior estimations are poorly. Let\u2019s look at the forecast created in November 2018: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-11-01\" data_cutoff = example_data . loc [: cutoff ] poor_trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 1 , 'gamma' : .9 } ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 10 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = poor_trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-11-01 00:00:00. Initial gradient: 1. Damping: 0.9. Initial log joint probability = -962.005 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -16.6821 0.000169582 0.22355 1 1 27 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -16.682 0.000103557 0.0974231 1 1 50 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -16.682 5.07955e-06 0.0182171 0.1133 1 78 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> The model with a large prior for simga_trend learned that the prior trend event estimates underestimated the trend change, and adjusted its forecast accordingly, whereas the default value would produce a larger forecasting error: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-11-01\" data_cutoff = example_data . loc [: cutoff ] poor_trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 1 , 'gamma' : .9 } ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = poor_trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-11-01 00:00:00. Initial gradient: 1. Damping: 0.9. Initial log joint probability = -979.779 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -21.5681 0.000488491 0.799235 1 1 27 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 38 -21.5671 6.15078e-05 0.00396993 1.018 0.1018 65 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Testing a very high sigma_trend value"},{"location":"tutorials/T0%20-%20Intro/","text":"How-to Tutorials The tutorial section is a more detailed explanation of the JudgyProphet functionality. It discusses how to model level events, trend events, and seasonality. It also gives a brief overview of hyperparameters settings. The tutorial is based on the jupyter notebools in the tutorial folder.","title":"How-to Tutorials"},{"location":"tutorials/T0%20-%20Intro/#how-to-tutorials","text":"The tutorial section is a more detailed explanation of the JudgyProphet functionality. It discusses how to model level events, trend events, and seasonality. It also gives a brief overview of hyperparameters settings. The tutorial is based on the jupyter notebools in the tutorial folder.","title":"How-to Tutorials"},{"location":"tutorials/T1%20-%20Level%20Events/","text":"Level Event In this tutorial we use judgyprophet to forecast a time series with what we call a level_event . It is a sudden change in level of the time series without an underlying trend change. An example would be the following: from judgyprophet.tutorials.resources import get_level_event example_data = get_level_event () example_data . plot . line () <AxesSubplot:> We can see a relatively stable constant trajectory, followed by a shift in that trajectory around April 2020. It is quite stable after that. The example above also shows the format of the data required by judgyprophet . The data should be a pandas Series , with the actuals as the entries, e.g.: 2019-01-01 3.287609 2019-02-01 4.753766 2019-03-01 3.955497 2019-04-01 4.451812 2019-05-01 5.345102 Freq: MS, dtype: float64 The index should denote the datetime element of the series, it should be ordered and have no gaps. It can either be a pandas index for specifically working with time series (e.g. pd.DatetimeIndex ), or just an integer based index -- this means you don't have to explicitly list dates. If it is a pandas time series index, the freq should be set. This allows judgyprophet to calculate the horizon during prediction. In our case the freq is set to be 'MS', meaning month start. Format the level event expectation for JudgyProphet Suppose that we are aware in January 2020 that an event is likely to happen in April 2020 which will change the level by approximately 10. We would encode this in judgyprophet as follows: level_events = [ { 'name' : 'Expected event 1' , 'index' : '2020-04-01' , 'c0' : 10 } ] Each level event is encoded as a dict with two required entries: the 'index' field, which is the index in the data when the event occurs. If this entry is fed into example_data.loc[] , then it should return a single value. It follows the standard pandas indexing rules (for example, see here ). The 'c0' field is the initial estimate by the business of what the impact of this level event will be. It is fed into the model as an informative prior on the level event mean; which is then updated in a Bayesian way. Forecasting with JudgyProphet before the event occurs Now let's pretend we're still in January 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet # Cutoff the data to January 2020 data_jan2020 = example_data . loc [: \"2020-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2020 , level_events = level_events , trend_events = [], sigma_base_bias = .1 , sigma_base_trend = .1 , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Post-event data for level event Expected event 1 less than 0 points. Event deactivated in model. Event index: 2020-04-01, training data end index: 2019-01-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -56.9093 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 3 -25.5963 0.272471 1.08052e-14 1 1 6 Optimization terminated normally: Convergence detected: gradient norm is below tolerance Let's plot the results... import pandas as pd import seaborn as sns predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_jan2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-02-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> We can see from the plot that the forecast captures the event pretty well. However the business estimate of the change-in-level event is probably slightly too high; which leads to the forecast to slightly overshoot the actuals. Forecasting with JudgyProphet after the event occurs This is where the Bayesian updating comes into its own. Let's now fit the forecast after the event has occurred. At this point, the impact of the event will be updated in a Bayesian way given what has been seen in the actuals. # Cutoff the data to June 2020 data_june2020 = example_data . loc [: \"2020-06-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_june2020 , level_events = level_events , trend_events = [], sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding level event Expected event 1 to model. Event index: 2020-04-01, training data start index: 2019-01-01 00:00:00, training data end index: 2020-06-01 00:00:00. Initial level: 10. Initial log joint probability = -17.0116 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 6 -2.93197 1.93616e-05 3.23115e-06 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results again: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_june2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-07-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> When judgyprophet predicts after the event occurs, it decreases the business estimate as it observes actuals.","title":"Tutorial 1 - Level Events"},{"location":"tutorials/T1%20-%20Level%20Events/#level-event","text":"In this tutorial we use judgyprophet to forecast a time series with what we call a level_event . It is a sudden change in level of the time series without an underlying trend change. An example would be the following: from judgyprophet.tutorials.resources import get_level_event example_data = get_level_event () example_data . plot . line () <AxesSubplot:> We can see a relatively stable constant trajectory, followed by a shift in that trajectory around April 2020. It is quite stable after that. The example above also shows the format of the data required by judgyprophet . The data should be a pandas Series , with the actuals as the entries, e.g.: 2019-01-01 3.287609 2019-02-01 4.753766 2019-03-01 3.955497 2019-04-01 4.451812 2019-05-01 5.345102 Freq: MS, dtype: float64 The index should denote the datetime element of the series, it should be ordered and have no gaps. It can either be a pandas index for specifically working with time series (e.g. pd.DatetimeIndex ), or just an integer based index -- this means you don't have to explicitly list dates. If it is a pandas time series index, the freq should be set. This allows judgyprophet to calculate the horizon during prediction. In our case the freq is set to be 'MS', meaning month start.","title":"Level Event"},{"location":"tutorials/T1%20-%20Level%20Events/#format-the-level-event-expectation-for-judgyprophet","text":"Suppose that we are aware in January 2020 that an event is likely to happen in April 2020 which will change the level by approximately 10. We would encode this in judgyprophet as follows: level_events = [ { 'name' : 'Expected event 1' , 'index' : '2020-04-01' , 'c0' : 10 } ] Each level event is encoded as a dict with two required entries: the 'index' field, which is the index in the data when the event occurs. If this entry is fed into example_data.loc[] , then it should return a single value. It follows the standard pandas indexing rules (for example, see here ). The 'c0' field is the initial estimate by the business of what the impact of this level event will be. It is fed into the model as an informative prior on the level event mean; which is then updated in a Bayesian way.","title":"Format the level event expectation for JudgyProphet"},{"location":"tutorials/T1%20-%20Level%20Events/#forecasting-with-judgyprophet-before-the-event-occurs","text":"Now let's pretend we're still in January 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet # Cutoff the data to January 2020 data_jan2020 = example_data . loc [: \"2020-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2020 , level_events = level_events , trend_events = [], sigma_base_bias = .1 , sigma_base_trend = .1 , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Post-event data for level event Expected event 1 less than 0 points. Event deactivated in model. Event index: 2020-04-01, training data end index: 2019-01-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -56.9093 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 3 -25.5963 0.272471 1.08052e-14 1 1 6 Optimization terminated normally: Convergence detected: gradient norm is below tolerance Let's plot the results... import pandas as pd import seaborn as sns predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_jan2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-02-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> We can see from the plot that the forecast captures the event pretty well. However the business estimate of the change-in-level event is probably slightly too high; which leads to the forecast to slightly overshoot the actuals.","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/T1%20-%20Level%20Events/#forecasting-with-judgyprophet-after-the-event-occurs","text":"This is where the Bayesian updating comes into its own. Let's now fit the forecast after the event has occurred. At this point, the impact of the event will be updated in a Bayesian way given what has been seen in the actuals. # Cutoff the data to June 2020 data_june2020 = example_data . loc [: \"2020-06-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_june2020 , level_events = level_events , trend_events = [], sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding level event Expected event 1 to model. Event index: 2020-04-01, training data start index: 2019-01-01 00:00:00, training data end index: 2020-06-01 00:00:00. Initial level: 10. Initial log joint probability = -17.0116 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 6 -2.93197 1.93616e-05 3.23115e-06 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results again: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_june2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-07-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> When judgyprophet predicts after the event occurs, it decreases the business estimate as it observes actuals.","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/T2%20-%20Trend%20Events/","text":"Trend Events In this tutorial we use judgyprophet to forecast a time series with a known/expected change in trend. This is called a trend_event and an example would be the following: from judgyprophet.tutorials.resources import get_trend_event example_data = get_trend_event () example_data . plot . line () <AxesSubplot:> We can see from the plot that there is an uptick in trend around September 2020. Format the trend event expectation for JudgyProphet Suppose we are in April 2020, and we have the prior knowledge that an event will occur in September. The expected change of the trend gradient will be an uptick of 6. We can encode this in judgyprophet as an expected trend event as follows: trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : 6 } ] Each trend event is encoded as a dict with two required entries: the 'index' field, which is the index in the data when the event occurs. If this entry is fed into example_data.loc[], then it should return a single value. It follows the standard pandas indexing rules (for example, see here). The 'm0' field is the initial estimate by the business of what the impact of this event on the trend will be (e.g. in our case we estimate it will increase the trend by 6). It is fed into the model as an informative prior on the level event mean; which is then updated in a Bayesian way. Forecasting with JudgyProphet before the event occurs Now let's pretend we're still in April 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_apr2020 = example_data . loc [: \"2020-04-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_apr2020 , level_events = [], trend_events = trend_events , sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -17.6559 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 5 -2.70162 0.00625172 1.10466e-05 1 1 8 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Forecasting with JudgyProphet after the event occurs We can see that with the business information, the forecast is better able to handle the sudden uptick in trend. After a while though, we can see that the business estimate of the trend is an overestimate. Let's see if the Bayesian updating can account for this. We now suppose we are re-forecasting the product in January 2021. from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: 6. Damping: None. Initial log joint probability = -18.4007 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -1.64341 1.13818e-05 8.53133e-05 1 1 10 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [ predictions . index <= \"2021-06-01\" , [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Although the forecast is still a slight overestimate, the Bayesian updating has downgraded the initial estimate somewhat. Trend event reducing the historic trend A trend event can also reduce the previous trend. A common real world examples for this case are a competitor entering the market and thus over time reducing your products market share. example_data = get_trend_event ( uptake = False ) example_data . plot . line () <AxesSubplot:> Format the trend event expectation for JudgyProphet In this case, we simply add a minus to the expected trend impact: trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : - 6 } ] Forecasting with JudgyProphet before the event occurs Again, we're still in April 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_apr2020 = example_data . loc [: \"2020-04-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_apr2020 , level_events = [], trend_events = trend_events , sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -3.20978 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -2.70162 5.03247e-05 6.65978e-05 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Forecasting with JudgyProphet after the event occurs And after the event, we again learn from the additional data points: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: -6. Damping: None. Initial log joint probability = -28.0997 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 6 -7.46664 0.000740991 0.000446113 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [ predictions . index <= \"2021-06-01\" , [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Damping In real world examples, we often observe that the initial trend after the event changes over time. A good example is the total sales of a product if this product is released to an additional new market. In this scenario, there is usually a period of strong uptake initially, followed by a slowing of uptake as the market saturates. We model this in judgyprophet by using damping. The damping model is a linear trend with damping, which is the same as that used in one of the most popular exponential smoothing methods: Holt's linear damped trend (see here ). Unlike the trend and level parameters, the damping is set by the user, and is not learnt during fitting. This is because we found learning using Bayesian fitting to be inaccurate. If you are not sure what the damping term should be we recommend using cross-validation, or observing similar market launches. The damping term is usually between 0.8 and 1 (where 1 means no damping, i.e. a linear model), it is equivalent to the $\\phi$ parameter in the description of Holt's linear damped trend. Those who know Prophet will remember it modelled this using logistic curves. We found this was extremely sensitive to the choice of the capacity parameter $C$ (the population the new entrant would eventually reach). This is why we opted for the damped linear trend, which we found to be more flexible. Let's look at a curve with damping: from judgyprophet.tutorials.resources import get_damped_trend_event example_data = get_damped_trend_event () print ( example_data . head ()) example_data . plot . line () 2019-06-01 3.287609 2019-07-01 5.253766 2019-08-01 4.955497 2019-09-01 5.951812 2019-10-01 7.345102 Freq: MS, dtype: float64 <AxesSubplot:> We can see there is an initial uptick in trend, followed by a plateauing effect as the market saturates. Format the damped trend event expectation for JudgyProphet We talk to the business and they assume the initial trend uptake is 5, with a damping parameter from analysing similar market entrants of .9. We encode this as a trend_event as follows, notice that we refer to the damping parameter as gamma : trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2020-01-01' , 'm0' : 5 , 'gamma' : .85 } ] Forecasting with JudgyProphet before the event occurs from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_oct2019 = example_data . loc [: \"2019-10-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_oct2019 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_oct2019 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2019-10-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) WARNING:judgyprophet.utils:Arg 'data' has less than 5 data points. Expect a poor fit. INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New saturating market entry less than 0 points. Event deactivated in model. Event index: 2020-01-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -4.75577 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 4 -2.08579 0.0190169 7.99064e-06 1 1 6 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> We can see the initial estimates are quite off this time. This is because the business overestimated the damping and the trend. Let's see what happens as we start to observe actuals. Forecasting with JudgyProphet after the event occurs from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 cutoff = \"2020-04-01\" data_cutoff = example_data . loc [: cutoff ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_cutoff , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2020-01-01, training data start index: 2019-06-01 00:00:00, training data end index: 2020-04-01 00:00:00. Initial gradient: 5. Damping: 0.85. Initial log joint probability = -10.4473 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 9 -2.49061 8.76664e-05 0.00143778 0.9171 0.9171 11 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> While the trend is still a little overestimated, it is definitely improving. But is there anything we can do to improve the situation? Unspecified Changepoints Like prophet, we enable the user to include unspecified changepoints into the forecast. Unexpected changepoints enables us to handle unexpected changes in the trend of level of the time series. This is done by setting the unspecified_changepoints parameter in the fit method of JudgyProphet . Unspecified changepoints are initially set to have no effect on the model, but if actuals are observed that deviate from the model, they will be 'turned on,' and change the model. The arg unspecified_changepoints either takes an integer as input, which will intersperse the changepoints equally across time, or a list of indexes, which will place changepoints at exactly those time points. These changepoints are given a Laplace prior with a mean of 0, and a scale set by the arg sigma_unspecified_changepoints . The sigma_unspecified_changepoints affects the L1 penalty on the unspecified changepoints. Set sigma to be high (e.g. .5 or greater) and the unspecified changepoints will be very sensitive. Set it low (e.g. 0.05), and it will be insensitive. Unlike prophet, setting these changepoints does not change the prediction. Only level_events and trend_events in the prediction horizon will affect the forecast. Let's see what affect these have on the previous damping example... from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 cutoff = \"2020-04-01\" data_cutoff = example_data . loc [: cutoff ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_cutoff , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2020-01-01, training data start index: 2019-06-01 00:00:00, training data end index: 2020-04-01 00:00:00. Initial gradient: 5. Damping: 0.85. WARNING:judgyprophet.utils:Unspecified changepoint with index 2020-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. Initial log joint probability = -85.6424 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 12 -2.55807 0.00253247 10.5928 0.0002553 0.001 57 LS failed, Hessian reset 19 -2.53784 0.00129929 12.9114 2.828 0.4174 69 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -2.49159 1.88991e-05 13.7481 0.05264 1 106 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 43 -2.49059 2.07785e-05 13.316 1.762e-06 0.001 150 LS failed, Hessian reset 49 -2.48998 7.5683e-06 12.3042 6.778e-07 0.001 193 LS failed, Hessian reset 59 -2.48991 3.40412e-07 12.2862 0.3482 0.3482 210 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 70 -2.4899 8.88435e-09 11.2343 6.928e-10 0.001 271 LS failed, Hessian reset Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance /Users/kpxh622/github/judgyprophet/judgyprophet/utils.py:31: UserWarning: Unspecified changepoint with index 2020-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. warnings.warn(msg) <AxesSubplot:xlabel='ds', ylabel='value'> We can see in this case the unspecified changepoints have improved the model fit significantly. We recommend caution with unspecified changepoints though, they come with a cost, and when your time series is quite noisy they might be overreactive. In this case it is recommended to tune your sigma_unspecified_changepoints accordingly, or limit the amount of changepoints you use.","title":"Tutorial 2 - Trend Events"},{"location":"tutorials/T2%20-%20Trend%20Events/#trend-events","text":"In this tutorial we use judgyprophet to forecast a time series with a known/expected change in trend. This is called a trend_event and an example would be the following: from judgyprophet.tutorials.resources import get_trend_event example_data = get_trend_event () example_data . plot . line () <AxesSubplot:> We can see from the plot that there is an uptick in trend around September 2020.","title":"Trend Events"},{"location":"tutorials/T2%20-%20Trend%20Events/#format-the-trend-event-expectation-for-judgyprophet","text":"Suppose we are in April 2020, and we have the prior knowledge that an event will occur in September. The expected change of the trend gradient will be an uptick of 6. We can encode this in judgyprophet as an expected trend event as follows: trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : 6 } ] Each trend event is encoded as a dict with two required entries: the 'index' field, which is the index in the data when the event occurs. If this entry is fed into example_data.loc[], then it should return a single value. It follows the standard pandas indexing rules (for example, see here). The 'm0' field is the initial estimate by the business of what the impact of this event on the trend will be (e.g. in our case we estimate it will increase the trend by 6). It is fed into the model as an informative prior on the level event mean; which is then updated in a Bayesian way.","title":"Format the trend event expectation for JudgyProphet"},{"location":"tutorials/T2%20-%20Trend%20Events/#forecasting-with-judgyprophet-before-the-event-occurs","text":"Now let's pretend we're still in April 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_apr2020 = example_data . loc [: \"2020-04-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_apr2020 , level_events = [], trend_events = trend_events , sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -17.6559 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 5 -2.70162 0.00625172 1.10466e-05 1 1 8 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/T2%20-%20Trend%20Events/#forecasting-with-judgyprophet-after-the-event-occurs","text":"We can see that with the business information, the forecast is better able to handle the sudden uptick in trend. After a while though, we can see that the business estimate of the trend is an overestimate. Let's see if the Bayesian updating can account for this. We now suppose we are re-forecasting the product in January 2021. from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: 6. Damping: None. Initial log joint probability = -18.4007 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -1.64341 1.13818e-05 8.53133e-05 1 1 10 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [ predictions . index <= \"2021-06-01\" , [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'> Although the forecast is still a slight overestimate, the Bayesian updating has downgraded the initial estimate somewhat.","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/T2%20-%20Trend%20Events/#trend-event-reducing-the-historic-trend","text":"A trend event can also reduce the previous trend. A common real world examples for this case are a competitor entering the market and thus over time reducing your products market share. example_data = get_trend_event ( uptake = False ) example_data . plot . line () <AxesSubplot:>","title":"Trend event reducing the historic trend"},{"location":"tutorials/T2%20-%20Trend%20Events/#format-the-trend-event-expectation-for-judgyprophet_1","text":"In this case, we simply add a minus to the expected trend impact: trend_events = [ { 'name' : \"New market entry\" , 'index' : '2020-09-01' , 'm0' : - 6 } ]","title":"Format the trend event expectation for JudgyProphet"},{"location":"tutorials/T2%20-%20Trend%20Events/#forecasting-with-judgyprophet-before-the-event-occurs_1","text":"Again, we're still in April 2020, and see what judgyprophet would have forecasted: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_apr2020 = example_data . loc [: \"2020-04-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_apr2020 , level_events = [], trend_events = trend_events , sigma_base_bias = 1. , sigma_base_trend = 1. , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New market entry less than 0 points. Event deactivated in model. Event index: 2020-09-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -3.20978 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 7 -2.70162 5.03247e-05 6.65978e-05 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance Plotting the results: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/T2%20-%20Trend%20Events/#forecasting-with-judgyprophet-after-the-event-occurs_1","text":"And after the event, we again learn from the additional data points: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_jan2021 = example_data . loc [: \"2021-01-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_jan2021 , level_events = [], trend_events = trend_events , unspecified_changepoints = 0 , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New market entry to model. Event index: 2020-09-01, training data start index: 2019-06-01 00:00:00, training data end index: 2021-01-01 00:00:00. Initial gradient: -6. Damping: None. Initial log joint probability = -28.0997 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 6 -7.46664 0.000740991 0.000446113 1 1 9 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [ predictions . index <= \"2021-06-01\" , [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_apr2020 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2020-05-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/T2%20-%20Trend%20Events/#damping","text":"In real world examples, we often observe that the initial trend after the event changes over time. A good example is the total sales of a product if this product is released to an additional new market. In this scenario, there is usually a period of strong uptake initially, followed by a slowing of uptake as the market saturates. We model this in judgyprophet by using damping. The damping model is a linear trend with damping, which is the same as that used in one of the most popular exponential smoothing methods: Holt's linear damped trend (see here ). Unlike the trend and level parameters, the damping is set by the user, and is not learnt during fitting. This is because we found learning using Bayesian fitting to be inaccurate. If you are not sure what the damping term should be we recommend using cross-validation, or observing similar market launches. The damping term is usually between 0.8 and 1 (where 1 means no damping, i.e. a linear model), it is equivalent to the $\\phi$ parameter in the description of Holt's linear damped trend. Those who know Prophet will remember it modelled this using logistic curves. We found this was extremely sensitive to the choice of the capacity parameter $C$ (the population the new entrant would eventually reach). This is why we opted for the damped linear trend, which we found to be more flexible. Let's look at a curve with damping: from judgyprophet.tutorials.resources import get_damped_trend_event example_data = get_damped_trend_event () print ( example_data . head ()) example_data . plot . line () 2019-06-01 3.287609 2019-07-01 5.253766 2019-08-01 4.955497 2019-09-01 5.951812 2019-10-01 7.345102 Freq: MS, dtype: float64 <AxesSubplot:> We can see there is an initial uptick in trend, followed by a plateauing effect as the market saturates.","title":"Damping"},{"location":"tutorials/T2%20-%20Trend%20Events/#format-the-damped-trend-event-expectation-for-judgyprophet","text":"We talk to the business and they assume the initial trend uptake is 5, with a damping parameter from analysing similar market entrants of .9. We encode this as a trend_event as follows, notice that we refer to the damping parameter as gamma : trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2020-01-01' , 'm0' : 5 , 'gamma' : .85 } ]","title":"Format the damped trend event expectation for JudgyProphet"},{"location":"tutorials/T2%20-%20Trend%20Events/#forecasting-with-judgyprophet-before-the-event-occurs_2","text":"from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 data_oct2019 = example_data . loc [: \"2019-10-01\" ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_oct2019 , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_oct2019 . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ \"2019-10-01\" :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) WARNING:judgyprophet.utils:Arg 'data' has less than 5 data points. Expect a poor fit. INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New saturating market entry less than 0 points. Event deactivated in model. Event index: 2020-01-01, training data end index: 2019-06-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -4.75577 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 4 -2.08579 0.0190169 7.99064e-06 1 1 6 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> We can see the initial estimates are quite off this time. This is because the business overestimated the damping and the trend. Let's see what happens as we start to observe actuals.","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/T2%20-%20Trend%20Events/#forecasting-with-judgyprophet-after-the-event-occurs_2","text":"from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 cutoff = \"2020-04-01\" data_cutoff = example_data . loc [: cutoff ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_cutoff , level_events = [], trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2020-01-01, training data start index: 2019-06-01 00:00:00, training data end index: 2020-04-01 00:00:00. Initial gradient: 5. Damping: 0.85. Initial log joint probability = -10.4473 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 9 -2.49061 8.76664e-05 0.00143778 0.9171 0.9171 11 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> While the trend is still a little overestimated, it is definitely improving. But is there anything we can do to improve the situation?","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/T2%20-%20Trend%20Events/#unspecified-changepoints","text":"Like prophet, we enable the user to include unspecified changepoints into the forecast. Unexpected changepoints enables us to handle unexpected changes in the trend of level of the time series. This is done by setting the unspecified_changepoints parameter in the fit method of JudgyProphet . Unspecified changepoints are initially set to have no effect on the model, but if actuals are observed that deviate from the model, they will be 'turned on,' and change the model. The arg unspecified_changepoints either takes an integer as input, which will intersperse the changepoints equally across time, or a list of indexes, which will place changepoints at exactly those time points. These changepoints are given a Laplace prior with a mean of 0, and a scale set by the arg sigma_unspecified_changepoints . The sigma_unspecified_changepoints affects the L1 penalty on the unspecified changepoints. Set sigma to be high (e.g. .5 or greater) and the unspecified changepoints will be very sensitive. Set it low (e.g. 0.05), and it will be insensitive. Unlike prophet, setting these changepoints does not change the prediction. Only level_events and trend_events in the prediction horizon will affect the forecast. Let's see what affect these have on the previous damping example... from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to January 2020 cutoff = \"2020-04-01\" data_cutoff = example_data . loc [: cutoff ] # Make the forecast with the business estimated level event # We have no trend events, so just provide the empty list. jp = JudgyProphet () # Because the event is beyond the actuals, judgyprophet throws a warning. # This is just because the Bayesian model at the event has no actuals to learn from. # The event is still used in predictions. jp . fit ( data = data_cutoff , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = 12 ) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2020-01-01, training data start index: 2019-06-01 00:00:00, training data end index: 2020-04-01 00:00:00. Initial gradient: 5. Damping: 0.85. WARNING:judgyprophet.utils:Unspecified changepoint with index 2020-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. Initial log joint probability = -85.6424 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 12 -2.55807 0.00253247 10.5928 0.0002553 0.001 57 LS failed, Hessian reset 19 -2.53784 0.00129929 12.9114 2.828 0.4174 69 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -2.49159 1.88991e-05 13.7481 0.05264 1 106 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 43 -2.49059 2.07785e-05 13.316 1.762e-06 0.001 150 LS failed, Hessian reset 49 -2.48998 7.5683e-06 12.3042 6.778e-07 0.001 193 LS failed, Hessian reset 59 -2.48991 3.40412e-07 12.2862 0.3482 0.3482 210 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 70 -2.4899 8.88435e-09 11.2343 6.928e-10 0.001 271 LS failed, Hessian reset Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance /Users/kpxh622/github/judgyprophet/judgyprophet/utils.py:31: UserWarning: Unspecified changepoint with index 2020-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. warnings.warn(msg) <AxesSubplot:xlabel='ds', ylabel='value'> We can see in this case the unspecified changepoints have improved the model fit significantly. We recommend caution with unspecified changepoints though, they come with a cost, and when your time series is quite noisy they might be overreactive. In this case it is recommended to tune your sigma_unspecified_changepoints accordingly, or limit the amount of changepoints you use.","title":"Unspecified Changepoints"},{"location":"tutorials/T3%20-%20Seasonality/","text":"Seasonality Similar to prophet , judgyprophet models seasonality as Fourier series and can handle both additive and multiplicative seasonality. However, the seasonality implementation is currently limited to the index frequency and does not support the split into weekly, monthly, and yearly. To enable seasonality, simply set the seasonal_period arg to a positive integer (e.g. 12 for monthly data, 7 for daily). The default seasonality is additive, to change this to multiplicative set the arg seasonal_type to be 'mult' . The Fourier order is set via the fourier_order parameter, with the default value set to seasonal_period - 1. The Fourier order determines how quickly the seasonality can change and the reducing order compared to the default parameters might help to avoid overfitting. Additive Seasonality In the case of additive seasonality, the amplitude of the seasonal variation is independent of the trend and is hence roughly constant over the time series. If additive seasonality is selected, judgyprophet will rescale the time series onto zero mean and standard variance. An example is shown here: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns from judgyprophet.tutorials.resources import get_additive_seasonality_linear_trend example_data = get_additive_seasonality_linear_trend () # Cutoff the data to October 2020 cutoff = \"2020-10-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We are passing in a simple time series without trend or level events. The seasonality is set to 12 # and the seasonality component is simply additive. jp . fit ( data = data_cutoff , level_events = [], trend_events = [], seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 12 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -891.479 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -1.34039 1.12595e-05 0.00168501 0.5461 0.5461 30 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 21 -1.34039 1.01095e-06 0.00067455 0.1367 0.9362 33 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Multiplicative Seasonality In case of multiplicative seasonality, the seasonal variations are changing proportional to the level of the series. If multiplicative seasonality is selected, judgyprophet will rescale the time series by shifting all values positive with standard variance. An example is shown here: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns from judgyprophet.tutorials.resources import get_multiplicative_seasonality_linear_trend example_data = get_multiplicative_seasonality_linear_trend () # Cutoff the data to October 2020 cutoff = \"2020-10-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # The multiplicative example time series has a constant trend component, but the seasonality # is multiplicative and has a large amplitude. Again the period is set to 12. jp . fit ( data = data_cutoff , level_events = [], trend_events = [], seasonal_period = 12 , seasonal_type = \"mult\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 12 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling by shifting all values positive with 1-sd. WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -775.468 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -105.965 0.0490619 1203.53 0.04941 1 32 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -12.2029 0.0634662 440.207 0.1485 0.1485 64 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -0.683534 0.0372809 68.3501 1 1 84 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -0.454028 0.00336031 7.70556 0.8053 0.8053 109 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -0.442297 0.000894112 6.38619 0.006837 1 134 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -0.402061 0.0581892 7.15489 0.5184 1 159 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -0.287525 0.0223029 0.741186 1 1 187 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -0.285187 0.000493407 1.35585 0.3357 1 213 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -0.285081 5.78588e-05 0.106578 0.2866 0.02866 238 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -0.28508 6.70665e-06 0.00713309 0.1648 0.1648 259 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 206 -0.28508 1.07542e-05 0.00613299 1 1 267 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Combining Seasonality with Events Both seasonality can be combined with trend events, damping, level events, and unspecified changepoints. We will now walk through an example time series which contains a damped trend event and shows additive seasonality. Let's look at the data: from judgyprophet.tutorials.resources import get_additive_seasonal_damped_trend_event example_data = get_additive_seasonal_damped_trend_event () example_data . plot . line () <AxesSubplot:> We can see from the plot that there is an uptick in trend around January 2018. The uptick in trend is quite steep until the end of 2019 where we observe stronger damping. We also see that the time series has a seasonal pattern, with a seasonal_period of 12 and a peak in December each year. Forecasting with JudgyProphet before the event occurs The estimate of the trend event is a trend increase of 6 with a damping parameter of 0.9. from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 6 , 'gamma' : .9 } ] # Cutoff the data to June 2017 cutoff = \"2017-06-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New saturating market entry less than 0 points. Event deactivated in model. Event index: 2018-01-01, training data end index: 2015-01-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -5618.69 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -19.5311 0.107624 53.5313 1 1 25 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -14.4873 0.00450173 32.1225 1 1 54 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -11.3416 0.0164259 63.5553 0.1261 1 83 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -10.031 0.00192964 42.0027 0.4045 0.4045 111 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -9.91568 0.00123052 20.6714 0.3407 1 136 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -9.74583 0.0178502 45.6554 1 1 161 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -9.58822 0.00240934 24.5607 0.1831 1 185 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -9.55939 0.000174537 18.265 1 1 214 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -9.55721 4.74996e-06 18.6232 1 1 243 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -9.55707 1.07478e-05 21.7289 1 1 267 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 219 -9.5541 1.0315e-05 21.3723 1 1 288 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 239 -9.50413 0.00075237 20.6816 0.6394 0.6394 309 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 259 -9.41589 0.000411908 21.7004 1 1 331 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 279 -9.39884 1.20103e-05 20.8879 0.3439 0.3439 355 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 299 -9.39799 4.26641e-06 20.0502 0.476 0.476 379 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 319 -9.37685 5.71275e-05 19.885 0.3824 0.3824 405 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 339 -9.34918 0.000126588 18.6708 0.9182 0.9182 429 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 359 -9.34728 1.3233e-05 20.7019 1 1 455 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 379 -9.33447 2.78134e-05 20.1768 0.5231 0.5231 477 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 399 -9.33284 2.29302e-06 20.0762 0.6157 0.6157 501 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 419 -9.33248 1.2898e-05 19.1065 0.08486 1 529 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 420 -9.33247 3.42574e-06 21.2674 1.793e-07 0.001 576 LS failed, Hessian reset 439 -9.33237 2.57199e-07 22.0328 0.3448 1 603 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 450 -9.33237 7.89272e-09 20.4987 0.2986 1 621 Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Forecasting with JudgyProphet after the event occurs We can see that the model picks up correctly the seasonal pattern and incorporates the trend event. After a few more data points are observed, the model learned that the initial trend event estimates were poorly and corrects its forecast accordingly. Let's look at the forecast repeated in June 2018: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 6 , 'gamma' : .9 } ] # Cutoff the data to June 2017 cutoff = \"2018-06-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-06-01 00:00:00. Initial gradient: 6. Damping: 0.9. WARNING:judgyprophet.utils:Unspecified changepoint with index 2018-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. Initial log joint probability = -4219.81 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -45.4011 0.0443425 326.047 1 1 26 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -15.3423 0.00201394 41.5814 1 1 53 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -11.4289 0.0222713 70.3068 1 1 82 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -9.74468 0.0019911 38.3992 0.8659 0.8659 110 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -9.55453 0.00466659 25.2859 0.949 0.949 137 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -9.42124 0.000328639 21.1329 0.3671 1 163 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -9.38936 0.00514148 27.2595 1 1 196 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -9.3399 0.00760439 37.8239 1 1 223 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -9.27552 0.000532321 24.6411 0.4927 0.4927 247 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -9.23377 0.00261612 16.9745 0.8399 0.8399 269 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 202 -9.23013 0.000104263 18.2691 5.753e-06 0.001 364 LS failed, Hessian reset 219 -9.19983 0.00127842 29.8317 1 1 381 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 239 -9.16268 0.00026094 21.9496 3.298 0.3298 403 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 259 -9.1381 0.00160896 29.4252 0.9121 0.9121 426 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 279 -9.11448 0.000430079 17.2828 1 1 451 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 299 -9.09913 0.000132984 15.3301 0.2225 0.2225 479 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 319 -9.09577 7.96264e-05 20.5328 0.9646 0.9646 507 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 339 -9.0927 5.35475e-06 18.2672 0.38 1 533 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 359 -9.09266 1.83214e-08 16.0514 1 1 567 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 365 -9.09266 6.04342e-09 18.2719 0.6683 0.6683 573 Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance /Users/kpxh622/github/judgyprophet/judgyprophet/utils.py:31: UserWarning: Unspecified changepoint with index 2018-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. warnings.warn(msg) <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Tutorial 3 - Seasonality"},{"location":"tutorials/T3%20-%20Seasonality/#seasonality","text":"Similar to prophet , judgyprophet models seasonality as Fourier series and can handle both additive and multiplicative seasonality. However, the seasonality implementation is currently limited to the index frequency and does not support the split into weekly, monthly, and yearly. To enable seasonality, simply set the seasonal_period arg to a positive integer (e.g. 12 for monthly data, 7 for daily). The default seasonality is additive, to change this to multiplicative set the arg seasonal_type to be 'mult' . The Fourier order is set via the fourier_order parameter, with the default value set to seasonal_period - 1. The Fourier order determines how quickly the seasonality can change and the reducing order compared to the default parameters might help to avoid overfitting.","title":"Seasonality"},{"location":"tutorials/T3%20-%20Seasonality/#additive-seasonality","text":"In the case of additive seasonality, the amplitude of the seasonal variation is independent of the trend and is hence roughly constant over the time series. If additive seasonality is selected, judgyprophet will rescale the time series onto zero mean and standard variance. An example is shown here: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns from judgyprophet.tutorials.resources import get_additive_seasonality_linear_trend example_data = get_additive_seasonality_linear_trend () # Cutoff the data to October 2020 cutoff = \"2020-10-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We are passing in a simple time series without trend or level events. The seasonality is set to 12 # and the seasonality component is simply additive. jp . fit ( data = data_cutoff , level_events = [], trend_events = [], seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 12 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -891.479 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -1.34039 1.12595e-05 0.00168501 0.5461 0.5461 30 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 21 -1.34039 1.01095e-06 0.00067455 0.1367 0.9362 33 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Additive Seasonality"},{"location":"tutorials/T3%20-%20Seasonality/#multiplicative-seasonality","text":"In case of multiplicative seasonality, the seasonal variations are changing proportional to the level of the series. If multiplicative seasonality is selected, judgyprophet will rescale the time series by shifting all values positive with standard variance. An example is shown here: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns from judgyprophet.tutorials.resources import get_multiplicative_seasonality_linear_trend example_data = get_multiplicative_seasonality_linear_trend () # Cutoff the data to October 2020 cutoff = \"2020-10-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # The multiplicative example time series has a constant trend component, but the seasonality # is multiplicative and has a large amplitude. Again the period is set to 12. jp . fit ( data = data_cutoff , level_events = [], trend_events = [], seasonal_period = 12 , seasonal_type = \"mult\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 12 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling by shifting all values positive with 1-sd. WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -775.468 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -105.965 0.0490619 1203.53 0.04941 1 32 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -12.2029 0.0634662 440.207 0.1485 0.1485 64 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -0.683534 0.0372809 68.3501 1 1 84 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -0.454028 0.00336031 7.70556 0.8053 0.8053 109 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -0.442297 0.000894112 6.38619 0.006837 1 134 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -0.402061 0.0581892 7.15489 0.5184 1 159 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -0.287525 0.0223029 0.741186 1 1 187 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -0.285187 0.000493407 1.35585 0.3357 1 213 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -0.285081 5.78588e-05 0.106578 0.2866 0.02866 238 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -0.28508 6.70665e-06 0.00713309 0.1648 0.1648 259 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 206 -0.28508 1.07542e-05 0.00613299 1 1 267 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Multiplicative Seasonality"},{"location":"tutorials/T3%20-%20Seasonality/#combining-seasonality-with-events","text":"Both seasonality can be combined with trend events, damping, level events, and unspecified changepoints. We will now walk through an example time series which contains a damped trend event and shows additive seasonality. Let's look at the data: from judgyprophet.tutorials.resources import get_additive_seasonal_damped_trend_event example_data = get_additive_seasonal_damped_trend_event () example_data . plot . line () <AxesSubplot:> We can see from the plot that there is an uptick in trend around January 2018. The uptick in trend is quite steep until the end of 2019 where we observe stronger damping. We also see that the time series has a seasonal pattern, with a seasonal_period of 12 and a peak in December each year.","title":"Combining Seasonality with Events"},{"location":"tutorials/T3%20-%20Seasonality/#forecasting-with-judgyprophet-before-the-event-occurs","text":"The estimate of the trend event is a trend increase of 6 with a damping parameter of 0.9. from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 6 , 'gamma' : .9 } ] # Cutoff the data to June 2017 cutoff = \"2017-06-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. WARNING:judgyprophet.judgyprophet:Post-event data for trend event New saturating market entry less than 0 points. Event deactivated in model. Event index: 2018-01-01, training data end index: 2015-01-01 00:00:00 WARNING:judgyprophet.utils:No active trend or level events (i.e. no event indexes overlap with data). The model will just fit a base trend to the data. Initial log joint probability = -5618.69 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -19.5311 0.107624 53.5313 1 1 25 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -14.4873 0.00450173 32.1225 1 1 54 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -11.3416 0.0164259 63.5553 0.1261 1 83 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -10.031 0.00192964 42.0027 0.4045 0.4045 111 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -9.91568 0.00123052 20.6714 0.3407 1 136 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -9.74583 0.0178502 45.6554 1 1 161 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -9.58822 0.00240934 24.5607 0.1831 1 185 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -9.55939 0.000174537 18.265 1 1 214 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -9.55721 4.74996e-06 18.6232 1 1 243 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -9.55707 1.07478e-05 21.7289 1 1 267 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 219 -9.5541 1.0315e-05 21.3723 1 1 288 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 239 -9.50413 0.00075237 20.6816 0.6394 0.6394 309 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 259 -9.41589 0.000411908 21.7004 1 1 331 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 279 -9.39884 1.20103e-05 20.8879 0.3439 0.3439 355 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 299 -9.39799 4.26641e-06 20.0502 0.476 0.476 379 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 319 -9.37685 5.71275e-05 19.885 0.3824 0.3824 405 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 339 -9.34918 0.000126588 18.6708 0.9182 0.9182 429 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 359 -9.34728 1.3233e-05 20.7019 1 1 455 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 379 -9.33447 2.78134e-05 20.1768 0.5231 0.5231 477 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 399 -9.33284 2.29302e-06 20.0762 0.6157 0.6157 501 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 419 -9.33248 1.2898e-05 19.1065 0.08486 1 529 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 420 -9.33247 3.42574e-06 21.2674 1.793e-07 0.001 576 LS failed, Hessian reset 439 -9.33237 2.57199e-07 22.0328 0.3448 1 603 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 450 -9.33237 7.89272e-09 20.4987 0.2986 1 621 Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet before the event occurs"},{"location":"tutorials/T3%20-%20Seasonality/#forecasting-with-judgyprophet-after-the-event-occurs","text":"We can see that the model picks up correctly the seasonal pattern and incorporates the trend event. After a few more data points are observed, the model learned that the initial trend event estimates were poorly and corrects its forecast accordingly. Let's look at the forecast repeated in June 2018: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 6 , 'gamma' : .9 } ] # Cutoff the data to June 2017 cutoff = \"2018-06-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 10 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-06-01 00:00:00. Initial gradient: 6. Damping: 0.9. WARNING:judgyprophet.utils:Unspecified changepoint with index 2018-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. Initial log joint probability = -4219.81 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -45.4011 0.0443425 326.047 1 1 26 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -15.3423 0.00201394 41.5814 1 1 53 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -11.4289 0.0222713 70.3068 1 1 82 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -9.74468 0.0019911 38.3992 0.8659 0.8659 110 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 99 -9.55453 0.00466659 25.2859 0.949 0.949 137 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 119 -9.42124 0.000328639 21.1329 0.3671 1 163 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 139 -9.38936 0.00514148 27.2595 1 1 196 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 159 -9.3399 0.00760439 37.8239 1 1 223 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 179 -9.27552 0.000532321 24.6411 0.4927 0.4927 247 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 199 -9.23377 0.00261612 16.9745 0.8399 0.8399 269 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 202 -9.23013 0.000104263 18.2691 5.753e-06 0.001 364 LS failed, Hessian reset 219 -9.19983 0.00127842 29.8317 1 1 381 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 239 -9.16268 0.00026094 21.9496 3.298 0.3298 403 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 259 -9.1381 0.00160896 29.4252 0.9121 0.9121 426 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 279 -9.11448 0.000430079 17.2828 1 1 451 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 299 -9.09913 0.000132984 15.3301 0.2225 0.2225 479 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 319 -9.09577 7.96264e-05 20.5328 0.9646 0.9646 507 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 339 -9.0927 5.35475e-06 18.2672 0.38 1 533 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 359 -9.09266 1.83214e-08 16.0514 1 1 567 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 365 -9.09266 6.04342e-09 18.2719 0.6683 0.6683 573 Optimization terminated normally: Convergence detected: absolute parameter change was below tolerance /Users/kpxh622/github/judgyprophet/judgyprophet/utils.py:31: UserWarning: Unspecified changepoint with index 2018-01-01 00:00:00 also specified as a level or trend event. Removing this changepoint. warnings.warn(msg) <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Forecasting with JudgyProphet after the event occurs"},{"location":"tutorials/T4%20-%20Hyperparameters/","text":"Hyperparameters judgyprophet gives full control over hyperparameters. These are mainly scale parameters which determine how sensitive judgyprophet is to actuals. The most useful of these are: sigma_level -- each level event is assigned a Normal prior with mean the business estimate ('c0'), and standard deviation is set to this arg. The lower this is, the closer the event will follow the business suggestions -- its default is 0.1. sigma_trend -- each trend event is assigned a Normal prior with mean the business estimate ('m0'), and standard deviation is set to this arg. The lower this is, the closer the event will follow the business suggestions -- its default is 0.1. sigma_unspecified_changepoints -- each unspecified changepoint is assigned a Laplace prior (equivalent to L1 penalty) with mean 0, and standard deviation set to this arg. The lower this is, the less likely the model will use this changepoint. Other hyperparameters are: sigma_base_bias -- the initial bias is assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. sigma_base_trend -- the initial trend is assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. sigma_seasonal -- the seasonality parameters are assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. Example of Hyperparameter impact The default hyperparameter values for judgyprophet tend to deliver reasonable estimations. However, there might be situations in which you would like to adjust those to pay more or less attention to prior knowledge. Values between 1 and 0.01 seem to deliver quite stable results. We will now adjusting the prior for the trend event to understand the hyperparameter impact. Let's load again the time series which contains a damped trend event and additive seasonality which we saw in the Seasonality tutorial. This time, we added some correlated noise after the trend event happened (between April and August 2018): from judgyprophet.tutorials.resources import get_additive_seasonal_damped_trend_event_correlated_noise example_data = get_additive_seasonal_damped_trend_event_correlated_noise () example_data . plot . line () <AxesSubplot:> The trend event parameters in this case are the exact solution to trend shown in the above time series: trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 9 , 'gamma' : .9 } ] Forecasting with the default hyperparameters We are now creating a forecast in July 2017. Using the default value for sigma_trend creates the following forecast: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-08-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-08-01 00:00:00. Initial gradient: 9. Damping: 0.9. Initial log joint probability = -1125.09 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 17 -24.2744 0.000161304 0.00638672 1 1 31 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Nevertheless, the default hyperparameter tend to underestimate the impact of the trend event: Since the model is learning from the previously observed data points (which contain the correlated noise), the model assumes that the prior trend event estimates were inaccurate and it corrects the estimated trend downwards. Testing a very low sigma_trend value If we are certain that our prior knowledge is correct and we assume a high volatility in our time series, we can reduce the prior value for sigma_trend . That will encourge the model to strictly follow initial trend event estimations given to it. In this case, adjusting the hyperparameter value can improve our forecast accuracy: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-08-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.01 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-08-01 00:00:00. Initial gradient: 9. Damping: 0.9. Initial log joint probability = -1191.51 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -42.6551 0.0255416 21.9616 1 1 25 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -40.5184 0.0027457 2.62096 1 1 51 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -40.4754 0.000243228 0.568846 1 1 74 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -40.474 0.000184754 0.147366 1 1 99 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 97 -40.474 6.17252e-05 0.0258339 1 1 121 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Testing a very high sigma_trend value If you are not certain if your estimations are correct prior to the event, it is sensible to assign a higher value to the sigma_trend parameter. This is beneficial in situations where our prior estimations are poorly. Let's look at the forecast created in November 2018: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-11-01\" data_cutoff = example_data . loc [: cutoff ] poor_trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 1 , 'gamma' : .9 } ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 10 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = poor_trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-11-01 00:00:00. Initial gradient: 1. Damping: 0.9. Initial log joint probability = -962.005 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -16.6821 0.000169582 0.22355 1 1 27 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -16.682 0.000103557 0.0974231 1 1 50 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -16.682 5.07955e-06 0.0182171 0.1133 1 78 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> The model with a large prior for simga_trend learned that the prior trend event estimates underestimated the trend change, and adjusted its forecast accordingly, whereas the default value would produce a larger forecasting error: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-11-01\" data_cutoff = example_data . loc [: cutoff ] poor_trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 1 , 'gamma' : .9 } ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = poor_trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-11-01 00:00:00. Initial gradient: 1. Damping: 0.9. Initial log joint probability = -979.779 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -21.5681 0.000488491 0.799235 1 1 27 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 38 -21.5671 6.15078e-05 0.00396993 1.018 0.1018 65 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Tutorial 4 - Hyperparameters"},{"location":"tutorials/T4%20-%20Hyperparameters/#hyperparameters","text":"judgyprophet gives full control over hyperparameters. These are mainly scale parameters which determine how sensitive judgyprophet is to actuals. The most useful of these are: sigma_level -- each level event is assigned a Normal prior with mean the business estimate ('c0'), and standard deviation is set to this arg. The lower this is, the closer the event will follow the business suggestions -- its default is 0.1. sigma_trend -- each trend event is assigned a Normal prior with mean the business estimate ('m0'), and standard deviation is set to this arg. The lower this is, the closer the event will follow the business suggestions -- its default is 0.1. sigma_unspecified_changepoints -- each unspecified changepoint is assigned a Laplace prior (equivalent to L1 penalty) with mean 0, and standard deviation set to this arg. The lower this is, the less likely the model will use this changepoint. Other hyperparameters are: sigma_base_bias -- the initial bias is assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. sigma_base_trend -- the initial trend is assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1. sigma_seasonal -- the seasonality parameters are assigned a Normal prior with mean 0, and standard deviation is set to this arg. The lower this is, the more this parameter will be penalised down. Default 1.","title":"Hyperparameters"},{"location":"tutorials/T4%20-%20Hyperparameters/#example-of-hyperparameter-impact","text":"The default hyperparameter values for judgyprophet tend to deliver reasonable estimations. However, there might be situations in which you would like to adjust those to pay more or less attention to prior knowledge. Values between 1 and 0.01 seem to deliver quite stable results. We will now adjusting the prior for the trend event to understand the hyperparameter impact. Let's load again the time series which contains a damped trend event and additive seasonality which we saw in the Seasonality tutorial. This time, we added some correlated noise after the trend event happened (between April and August 2018): from judgyprophet.tutorials.resources import get_additive_seasonal_damped_trend_event_correlated_noise example_data = get_additive_seasonal_damped_trend_event_correlated_noise () example_data . plot . line () <AxesSubplot:> The trend event parameters in this case are the exact solution to trend shown in the above time series: trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 9 , 'gamma' : .9 } ]","title":"Example of Hyperparameter impact"},{"location":"tutorials/T4%20-%20Hyperparameters/#forecasting-with-the-default-hyperparameters","text":"We are now creating a forecast in July 2017. Using the default value for sigma_trend creates the following forecast: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-08-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-08-01 00:00:00. Initial gradient: 9. Damping: 0.9. Initial log joint probability = -1125.09 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 17 -24.2744 0.000161304 0.00638672 1 1 31 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> Nevertheless, the default hyperparameter tend to underestimate the impact of the trend event: Since the model is learning from the previously observed data points (which contain the correlated noise), the model assumes that the prior trend event estimates were inaccurate and it corrects the estimated trend downwards.","title":"Forecasting with the default hyperparameters"},{"location":"tutorials/T4%20-%20Hyperparameters/#testing-a-very-low-sigma_trend-value","text":"If we are certain that our prior knowledge is correct and we assume a high volatility in our time series, we can reduce the prior value for sigma_trend . That will encourge the model to strictly follow initial trend event estimations given to it. In this case, adjusting the hyperparameter value can improve our forecast accuracy: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-08-01\" data_cutoff = example_data . loc [: cutoff ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.01 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-08-01 00:00:00. Initial gradient: 9. Damping: 0.9. Initial log joint probability = -1191.51 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -42.6551 0.0255416 21.9616 1 1 25 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -40.5184 0.0027457 2.62096 1 1 51 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -40.4754 0.000243228 0.568846 1 1 74 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 79 -40.474 0.000184754 0.147366 1 1 99 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 97 -40.474 6.17252e-05 0.0258339 1 1 121 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Testing a very low sigma_trend value"},{"location":"tutorials/T4%20-%20Hyperparameters/#testing-a-very-high-sigma_trend-value","text":"If you are not certain if your estimations are correct prior to the event, it is sensible to assign a higher value to the sigma_trend parameter. This is beneficial in situations where our prior estimations are poorly. Let's look at the forecast created in November 2018: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-11-01\" data_cutoff = example_data . loc [: cutoff ] poor_trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 1 , 'gamma' : .9 } ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 10 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = poor_trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-11-01 00:00:00. Initial gradient: 1. Damping: 0.9. Initial log joint probability = -962.005 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -16.6821 0.000169582 0.22355 1 1 27 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 39 -16.682 0.000103557 0.0974231 1 1 50 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 59 -16.682 5.07955e-06 0.0182171 0.1133 1 78 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'> The model with a large prior for simga_trend learned that the prior trend event estimates underestimated the trend change, and adjusted its forecast accordingly, whereas the default value would produce a larger forecasting error: from judgyprophet import JudgyProphet import pandas as pd import seaborn as sns # Cutoff the data to June 2017 cutoff = \"2018-11-01\" data_cutoff = example_data . loc [: cutoff ] poor_trend_events = [ { 'name' : \"New saturating market entry\" , 'index' : '2018-01-01' , 'm0' : 1 , 'gamma' : .9 } ] jp = JudgyProphet () # We have one trend event and no level events. The seasonality is additive again. jp . fit ( data = data_cutoff , sigma_trend = 0.1 , level_events = [], unspecified_changepoints = 0 , sigma_unspecified_changepoints = .2 , trend_events = poor_trend_events , seasonal_period = 12 , seasonal_type = \"add\" , # Set random seed for reproducibility seed = 13 ) predictions = jp . predict ( horizon = int ( 36 )) # Plot the data: predict_df = ( predictions . reset_index () . rename ( columns = { 'index' : 'ds' , 'forecast' : 'value' }) . assign ( method = \"JudgyProphet\" ) . loc [:, [ \"ds\" , \"value\" , \"insample\" , \"method\" ]] ) actuals_df = ( data_cutoff . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Actuals\" , insample = True ) ) future_actuals_df = ( example_data . loc [ cutoff :] . reset_index () . rename ( columns = { 'index' : 'ds' , 0 : 'value' }) . assign ( method = \"Future Actuals\" , insample = False ) ) plot_df = ( pd . concat ([ predict_df , actuals_df , future_actuals_df ]) . reset_index ( drop = True ) ) sns . lineplot ( data = plot_df , x = 'ds' , y = 'value' , hue = 'method' , style = 'insample' , style_order = [ True , False ]) INFO:judgyprophet.judgyprophet:Rescaling onto 0-mean, 1-sd. INFO:judgyprophet.judgyprophet:Adding trend event New saturating market entry to model. Event index: 2018-01-01, training data start index: 2015-01-01 00:00:00, training data end index: 2018-11-01 00:00:00. Initial gradient: 1. Damping: 0.9. Initial log joint probability = -979.779 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 19 -21.5681 0.000488491 0.799235 1 1 27 Iter log prob ||dx|| ||grad|| alpha alpha0 # evals Notes 38 -21.5671 6.15078e-05 0.00396993 1.018 0.1018 65 Optimization terminated normally: Convergence detected: relative gradient magnitude is below tolerance <AxesSubplot:xlabel='ds', ylabel='value'>","title":"Testing a very high sigma_trend value"}]}